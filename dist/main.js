// Generated by Haxe 4.0.5
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var Controller = function(model,view) {
	this.fixedTimeLeft = 0;
	this.fixedTimeStep = 2.08333333333333348;
	this.paused = false;
	this.started = false;
	this.model = model;
	this.view = view;
	this.events = new events_Events();
	this.physics = new physics_Physics(this.model);
	this.viewport = new geom_Rectangle(0,0,0,0);
	this.gamepad = new gamepad_multi_MultiGamepad();
	this.coroutines = new coroutines_Coroutines();
	this.loader = new loader_Loader();
	this.model.setController(this);
};
Controller.__name__ = true;
Controller.createInstance = function(model,view) {
	if(Controller.instance == null) {
		Controller.instance = new Controller(model,view);
	}
	return Controller.instance;
};
Controller.getInstance = function() {
	return Controller.instance;
};
Controller.prototype = {
	start: function() {
		var _gthis = this;
		if(!this.started) {
			this.started = true;
			this.init();
			var loop = null;
			loop = function(currentTime) {
				if(!_gthis.paused) {
					var viewport = new geom_Rectangle(0,0,window.innerWidth,window.innerHeight);
					if(!_gthis.viewport.equal(viewport)) {
						viewport.copyTo(_gthis.viewport);
						_gthis.view.resize(viewport);
					}
					_gthis.events.processQueue();
					_gthis.coroutines.update();
					var deltaTime = _gthis.lastTime == null ? 0 : currentTime - _gthis.lastTime;
					_gthis.fixedTimeLeft += deltaTime;
					while(_gthis.fixedTimeLeft >= _gthis.fixedTimeStep) {
						_gthis.fixedUpdate(_gthis.fixedTimeStep);
						_gthis.fixedTimeLeft -= _gthis.fixedTimeStep;
					}
					_gthis.update(deltaTime);
					_gthis.lastTime = currentTime;
					window.requestAnimationFrame(loop);
				}
			};
			window.requestAnimationFrame(loop);
		}
	}
	,init: function() {
		var _gthis = this;
		this.model.init();
		this.gamepad.on("axispressed",function(event) {
			_gthis.events.push(event);
			return;
		});
		this.gamepad.on("axisreleased",function(event1) {
			_gthis.events.push(event1);
			return;
		});
		this.gamepad.on("buttonpressed",function(event2) {
			_gthis.events.push(event2);
			return;
		});
		this.gamepad.on("buttonreleased",function(event3) {
			_gthis.events.push(event3);
			return;
		});
	}
	,fixedUpdate: function(deltaTime) {
		this.model.fixedUpdate(deltaTime);
		this.physics.fixedUpdate(deltaTime);
	}
	,update: function(deltaTime) {
		if(this.started && !this.view.visible) {
			this.view.visible = true;
		}
		this.view.update(deltaTime);
	}
	,__class__: Controller
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var Main = function() { };
Main.__name__ = true;
Main.main = function() {
	var model = new Model();
	var controller = Controller.createInstance(model,new View(model));
	controller.start();
	window.Controller = Controller;
	window.Coroutines = coroutines_Coroutines;
	window.Result = coroutines_Result;
};
Math.__name__ = true;
var physics_PhysicsModel = function() { };
physics_PhysicsModel.__name__ = true;
physics_PhysicsModel.__isInterface__ = true;
physics_PhysicsModel.prototype = {
	__class__: physics_PhysicsModel
};
var Model = function() {
	this.world = new entities_World();
	this.hero = new entities_Hero();
	var _g = [];
	_g.push(new entities_Monster());
	_g.push(new entities_Monster());
	_g.push(new entities_Monster());
	_g.push(new entities_Monster());
	_g.push(new entities_Monster());
	_g.push(new entities_Monster());
	_g.push(new entities_Monster());
	_g.push(new entities_Monster());
	_g.push(new entities_Monster());
	_g.push(new entities_Monster());
	this.monsters = _g;
};
Model.__name__ = true;
Model.__interfaces__ = [physics_PhysicsModel];
Model.prototype = {
	setController: function(controller) {
		this.controller = controller;
	}
	,init: function() {
		var tileSize = this.world.tileSize;
		var gridSize = this.world.gridSize;
		var tmp = ((Math.random() * 4 | 0) + 5) * tileSize.x;
		this.hero.position.x = tmp * 2;
		var tmp1 = ((Math.random() * 3 | 0) + 3) * tileSize.y;
		this.hero.position.y = tmp1 * 2;
		while(!this.world.canMove(this.hero,this.hero.position)) {
			var tmp2 = ((Math.random() * 4 | 0) + 5) * tileSize.x;
			this.hero.position.x = tmp2 * 2;
			var tmp3 = ((Math.random() * 3 | 0) + 3) * tileSize.y;
			this.hero.position.y = tmp3 * 2;
		}
		var heroRegion = new geom_Rectangle(this.hero.position.x + this.hero.bounds.x - this.world.tileSize.x,this.hero.position.y + this.hero.bounds.y - this.world.tileSize.y,this.hero.bounds.width + 2 * this.world.tileSize.x,this.hero.bounds.height + 2 * this.world.tileSize.y);
		var _g = 0;
		var _g1 = this.monsters.slice(0,4);
		while(_g < _g1.length) {
			var monster = _g1[_g];
			++_g;
			monster.active = true;
			var x = Math.random();
			monster.position.x = ((x * (gridSize.x / 2 - 2) | 0) + 1) * tileSize.x * 2;
			var x1 = Math.random();
			monster.position.y = ((x1 * (gridSize.y / 2 - 2) | 0) + 1) * tileSize.y * 2;
			while(!this.world.canMove(monster,monster.position) || geom_RectangleOperations.overlap(heroRegion,monster.bounds)) {
				var x2 = Math.random();
				monster.position.x = ((x2 * (gridSize.x / 2 - 2) | 0) + 1) * tileSize.x * 2;
				var x3 = Math.random();
				monster.position.y = ((x3 * (gridSize.y / 2 - 2) | 0) + 1) * tileSize.y * 2;
			}
		}
	}
	,fixedUpdate: function(deltaTime) {
		if(this.hero.active) {
			this.hero.states.update();
		}
		var _g = 0;
		var _g1 = this.monsters;
		while(_g < _g1.length) {
			var monster = _g1[_g];
			++_g;
			if(monster.active) {
				monster.states.update();
			}
		}
	}
	,getBodies: function() {
		if(this.hero.active) {
			var tmp = [js_Boot.__cast(this.hero , physics_Body)];
			var _g = [];
			var _g1 = 0;
			var _g2 = this.monsters;
			while(_g1 < _g2.length) {
				var v = _g2[_g1];
				++_g1;
				if(v.active) {
					_g.push(v);
				}
			}
			return tmp.concat(_g);
		} else {
			var _g3 = [];
			var _g11 = 0;
			var _g21 = this.monsters;
			while(_g11 < _g21.length) {
				var v1 = _g21[_g11];
				++_g11;
				if(v1.active) {
					_g3.push(v1);
				}
			}
			return _g3;
		}
	}
	,move: function(body,position) {
		var displacement = position.clone().subtract(body.position);
		body.position.x += displacement.x;
		if(!this.world.canMove(body,body.position)) {
			this.resolveCollisionX(body,displacement);
		}
		body.position.y += displacement.y;
		if(!this.world.canMove(body,body.position)) {
			this.resolveCollisionY(body,displacement);
		}
	}
	,resolveCollisionX: function(body,displacement) {
		var topCorner = displacement.x >= 0 ? body.position.clone().add(new geom_Point2D(body.bounds.x,body.bounds.y)).add(new geom_Point2D(body.bounds.width,0)) : body.position.clone().add(new geom_Point2D(body.bounds.x,body.bounds.y));
		var bottomCorner = topCorner.clone().add(new geom_Point2D(0,body.bounds.height));
		if(displacement.x >= 0) {
			body.position.x = Math.floor((body.position.x + body.bounds.x + body.bounds.width) / this.world.tileSize.x) * this.world.tileSize.x - body.bounds.x - body.bounds.width;
		} else {
			body.position.x = Math.ceil((body.position.x + body.bounds.x) / this.world.tileSize.x) * this.world.tileSize.x;
		}
		if(!this.world.canMovePoint(topCorner) && this.world.canMovePoint(bottomCorner)) {
			var nudge = Math.abs(displacement.x) / Math.sqrt(2);
			if(nudge > displacement.y) {
				if(this.world.canMovePoint(topCorner.clone().add(new geom_Point2D(0,nudge)))) {
					displacement.y = this.world.tileSize.y - topCorner.y % this.world.tileSize.y;
				} else {
					displacement.y = nudge;
				}
			}
		} else if(this.world.canMovePoint(topCorner) && !this.world.canMovePoint(bottomCorner)) {
			var nudge1 = -Math.abs(displacement.x) / Math.sqrt(2);
			if(nudge1 < displacement.y) {
				if(this.world.canMovePoint(bottomCorner.clone().add(new geom_Point2D(0,nudge1)))) {
					displacement.y = -bottomCorner.y % (2 * this.world.tileSize.y);
				} else {
					displacement.y = nudge1;
				}
			}
		}
	}
	,resolveCollisionY: function(body,displacement) {
		var leftCorner = displacement.y >= 0 ? body.position.clone().add(new geom_Point2D(body.bounds.x,body.bounds.y)).add(new geom_Point2D(0,body.bounds.height)) : body.position.clone().add(new geom_Point2D(body.bounds.x,body.bounds.y));
		var rightCorner = leftCorner.clone().add(new geom_Point2D(body.bounds.width,0));
		if(displacement.y >= 0) {
			body.position.y = Math.floor((body.position.y + body.bounds.y + body.bounds.height) / this.world.tileSize.y) * this.world.tileSize.y - body.bounds.y - body.bounds.height;
		} else {
			body.position.y = Math.ceil((body.position.y + body.bounds.y) / this.world.tileSize.y) * this.world.tileSize.y;
		}
		if(!this.world.canMovePoint(leftCorner) && this.world.canMovePoint(rightCorner)) {
			var nudge = Math.abs(displacement.y) / Math.sqrt(2);
			if(nudge > displacement.x) {
				if(this.world.canMovePoint(leftCorner.clone().add(new geom_Point2D(nudge,0)))) {
					body.position.x = Math.floor((body.position.x + nudge) / this.world.tileSize.x) * this.world.tileSize.x;
				} else {
					body.position.x += nudge;
				}
			}
		} else if(this.world.canMovePoint(leftCorner) && !this.world.canMovePoint(rightCorner)) {
			var nudge1 = -Math.abs(displacement.y) / Math.sqrt(2);
			if(nudge1 < displacement.x) {
				if(this.world.canMovePoint(rightCorner.clone().add(new geom_Point2D(nudge1,0)))) {
					body.position.x += -rightCorner.x % this.world.tileSize.x;
				} else {
					body.position.x += nudge1;
				}
			}
		}
	}
	,__class__: Model
};
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var View = function(model) {
	this.monsters = [];
	this.tiles = [];
	this.visible = false;
	this.model = model;
	this.root = this.createRoot();
	this.scene = this.createScene();
	this.root.appendChild(this.scene);
	this.world = this.createWorld();
	this.scene.appendChild(this.world);
	var _g = 0;
	var _g1 = model.world.tileIds.length;
	while(_g < _g1) {
		var index = _g++;
		var tileId = model.world.tileIds[index];
		var x = index % model.world.gridSize.x * model.world.tileSize.x;
		var y = (index / model.world.gridSize.x | 0) * model.world.tileSize.y;
		var tile = this.createTile(tileId,x,y,model.world.tileSize.x,model.world.tileSize.y);
		this.world.appendChild(tile);
		this.tiles.push(tile);
	}
	var _g2 = 0;
	var _g3 = model.monsters;
	while(_g2 < _g3.length) {
		var monsterModel = _g3[_g2];
		++_g2;
		var monster = this.createMonster(monsterModel);
		this.scene.appendChild(monster);
		this.monsters.push(monster);
	}
	this.hero = this.createHero(model.hero);
	this.scene.appendChild(this.hero);
	window.document.body.appendChild(this.root);
};
View.__name__ = true;
View.prototype = {
	update: function(deltaTime) {
		this.root.style.visibility = this.visible ? "" : "hidden";
		this.hero.style.visibility = this.model.hero.active ? "" : "hidden";
		if(this.model.hero.active) {
			this.hero.setAttributeNS(null,"cx",this.model.hero.position.x + this.model.hero.bounds.width / 2 + "px");
			this.hero.setAttributeNS(null,"cy",this.model.hero.position.y + this.model.hero.bounds.height / 2 + "px");
			this.hero.setAttributeNS(null,"rx",this.model.hero.bounds.width / 2 + "px");
			this.hero.setAttributeNS(null,"yy",this.model.hero.bounds.height / 2 + "px");
		}
		var _g = 0;
		var _g1 = this.model.monsters.length;
		while(_g < _g1) {
			var index = _g++;
			var monsterModel = this.model.monsters[index];
			var monsterView = this.monsters[index];
			monsterView.style.visibility = monsterModel.active ? "" : "hidden";
			if(monsterModel.active) {
				monsterView.setAttributeNS(null,"cx",monsterModel.position.x + monsterModel.bounds.width / 2 + "px");
				monsterView.setAttributeNS(null,"cy",monsterModel.position.y + monsterModel.bounds.height / 2 + "px");
				monsterView.setAttributeNS(null,"rx",monsterModel.bounds.width / 2 + "px");
				monsterView.setAttributeNS(null,"yy",monsterModel.bounds.height / 2 + "px");
			}
		}
	}
	,resize: function(viewport) {
		var width = this.model.world.gridSize.x * this.model.world.tileSize.x;
		var height = this.model.world.gridSize.y * this.model.world.tileSize.y;
		var scale = Math.min(viewport.width / width,viewport.height / height);
		this.scene.setAttributeNS(null,"transform","scale(" + scale + ") translate(" + (viewport.width / scale - width) / 2 + " " + (viewport.height / scale - height) / 2 + ")");
		this.root.setAttributeNS(null,"width",viewport.width + "");
		this.root.setAttributeNS(null,"height",viewport.height + "");
	}
	,createRoot: function() {
		var _g = new haxe_ds_StringMap();
		var value = window.innerWidth;
		if(__map_reserved["width"] != null) {
			_g.setReserved("width",value);
		} else {
			_g.h["width"] = value;
		}
		var value1 = window.innerHeight;
		if(__map_reserved["height"] != null) {
			_g.setReserved("height",value1);
		} else {
			_g.h["height"] = value1;
		}
		var _g1 = new haxe_ds_StringMap();
		var value2 = "hidden";
		if(__map_reserved["visibility"] != null) {
			_g1.setReserved("visibility",value2);
		} else {
			_g1.h["visibility"] = value2;
		}
		return this.createElement("svg",_g,_g1);
	}
	,createScene: function() {
		var _g = new haxe_ds_StringMap();
		var value = "scene";
		if(__map_reserved["class"] != null) {
			_g.setReserved("class",value);
		} else {
			_g.h["class"] = value;
		}
		return this.createElement("g",_g);
	}
	,createWorld: function() {
		var _g = new haxe_ds_StringMap();
		var value = "world";
		if(__map_reserved["class"] != null) {
			_g.setReserved("class",value);
		} else {
			_g.h["class"] = value;
		}
		return this.createElement("g",_g);
	}
	,createTile: function(tileId,x,y,width,height) {
		var _g = new haxe_ds_StringMap();
		var value = ["ground","block"][tileId];
		if(__map_reserved["class"] != null) {
			_g.setReserved("class",value);
		} else {
			_g.h["class"] = value;
		}
		var value1 = "" + x + "px";
		if(__map_reserved["x"] != null) {
			_g.setReserved("x",value1);
		} else {
			_g.h["x"] = value1;
		}
		var value2 = "" + y + "px";
		if(__map_reserved["y"] != null) {
			_g.setReserved("y",value2);
		} else {
			_g.h["y"] = value2;
		}
		var value3 = "" + width + "px";
		if(__map_reserved["width"] != null) {
			_g.setReserved("width",value3);
		} else {
			_g.h["width"] = value3;
		}
		var value4 = "" + height + "px";
		if(__map_reserved["height"] != null) {
			_g.setReserved("height",value4);
		} else {
			_g.h["height"] = value4;
		}
		var value5 = ["#303030","#808080"][tileId];
		if(__map_reserved["fill"] != null) {
			_g.setReserved("fill",value5);
		} else {
			_g.h["fill"] = value5;
		}
		var value6 = "crispEdges";
		if(__map_reserved["shape-rendering"] != null) {
			_g.setReserved("shape-rendering",value6);
		} else {
			_g.h["shape-rendering"] = value6;
		}
		return this.createElement("rect",_g);
	}
	,createHero: function(hero) {
		var _g = new haxe_ds_StringMap();
		var value = hero.kind;
		if(__map_reserved["class"] != null) {
			_g.setReserved("class",value);
		} else {
			_g.h["class"] = value;
		}
		var value1 = "" + hero.bounds.width / 2 + "px";
		if(__map_reserved["cx"] != null) {
			_g.setReserved("cx",value1);
		} else {
			_g.h["cx"] = value1;
		}
		var value2 = "" + hero.bounds.height / 2 + "px";
		if(__map_reserved["cy"] != null) {
			_g.setReserved("cy",value2);
		} else {
			_g.h["cy"] = value2;
		}
		var value3 = "" + hero.bounds.width / 2 + "px";
		if(__map_reserved["rx"] != null) {
			_g.setReserved("rx",value3);
		} else {
			_g.h["rx"] = value3;
		}
		var value4 = "" + hero.bounds.height / 2 + "px";
		if(__map_reserved["ry"] != null) {
			_g.setReserved("ry",value4);
		} else {
			_g.h["ry"] = value4;
		}
		var value5 = "#3366cc";
		if(__map_reserved["fill"] != null) {
			_g.setReserved("fill",value5);
		} else {
			_g.h["fill"] = value5;
		}
		return this.createElement("ellipse",_g);
	}
	,createMonster: function(monster) {
		var _g = new haxe_ds_StringMap();
		var value = monster.kind;
		if(__map_reserved["class"] != null) {
			_g.setReserved("class",value);
		} else {
			_g.h["class"] = value;
		}
		var value1 = "" + monster.bounds.width / 2 + "px";
		if(__map_reserved["cx"] != null) {
			_g.setReserved("cx",value1);
		} else {
			_g.h["cx"] = value1;
		}
		var value2 = "" + monster.bounds.height / 2 + "px";
		if(__map_reserved["cy"] != null) {
			_g.setReserved("cy",value2);
		} else {
			_g.h["cy"] = value2;
		}
		var value3 = "" + monster.bounds.width / 2 + "px";
		if(__map_reserved["rx"] != null) {
			_g.setReserved("rx",value3);
		} else {
			_g.h["rx"] = value3;
		}
		var value4 = "" + monster.bounds.height / 2 + "px";
		if(__map_reserved["ry"] != null) {
			_g.setReserved("ry",value4);
		} else {
			_g.h["ry"] = value4;
		}
		var value5 = "#cc0066";
		if(__map_reserved["fill"] != null) {
			_g.setReserved("fill",value5);
		} else {
			_g.h["fill"] = value5;
		}
		return this.createElement("ellipse",_g);
	}
	,createElement: function(name,attributes,style) {
		var element = window.document.createElementNS("http://www.w3.org/2000/svg",name);
		if(attributes != null) {
			var _g = new haxe_iterators_MapKeyValueIterator(attributes);
			while(_g.hasNext()) {
				var _g1 = _g.next();
				var key = _g1.key;
				var value = _g1.value;
				element.setAttributeNS(null,key,value);
			}
		}
		if(style != null) {
			var _g2 = new haxe_iterators_MapKeyValueIterator(style);
			while(_g2.hasNext()) {
				var _g11 = _g2.next();
				var key1 = _g11.key;
				var value1 = _g11.value;
				element.style[key1] = value1;
			}
		}
		return element;
	}
	,__class__: View
};
var coroutines_Coroutines = function() {
	this.stacks = [];
};
coroutines_Coroutines.__name__ = true;
coroutines_Coroutines.prototype = {
	add: function(coroutine) {
		this.stacks.push([coroutine]);
	}
	,remove: function(coroutine) {
		var _g = [];
		var _g1 = 0;
		var _g2 = this.stacks;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(v.length > 0 && v[0] != coroutine) {
				_g.push(v);
			}
		}
		this.stacks = _g;
	}
	,update: function() {
		var _g = 0;
		var _g1 = this.stacks.slice(0,this.stacks.length);
		while(_g < _g1.length) {
			var stack = _g1[_g];
			++_g;
			var top = stack.pop();
			var _g2 = top();
			switch(_g2._hx_index) {
			case 0:
				break;
			case 1:
				stack.push(top);
				break;
			case 2:
				var next = _g2.next;
				stack.push(next);
				break;
			case 3:
				var next1 = _g2.next;
				stack.push(top);
				stack.push(next1);
				break;
			}
		}
		var _g3 = [];
		var _g11 = 0;
		var _g21 = this.stacks;
		while(_g11 < _g21.length) {
			var v = _g21[_g11];
			++_g11;
			if(v.length > 0) {
				_g3.push(v);
			}
		}
		this.stacks = _g3;
	}
	,__class__: coroutines_Coroutines
};
var coroutines_Result = $hxEnums["coroutines.Result"] = { __ename__ : true, __constructs__ : ["Terminate","Continue","Return","Push"]
	,Terminate: {_hx_index:0,__enum__:"coroutines.Result",toString:$estr}
	,Continue: {_hx_index:1,__enum__:"coroutines.Result",toString:$estr}
	,Return: ($_=function(next) { return {_hx_index:2,next:next,__enum__:"coroutines.Result",toString:$estr}; },$_.__params__ = ["next"],$_)
	,Push: ($_=function(next) { return {_hx_index:3,next:next,__enum__:"coroutines.Result",toString:$estr}; },$_.__params__ = ["next"],$_)
};
var physics_Body = function() { };
physics_Body.__name__ = true;
physics_Body.__isInterface__ = true;
physics_Body.prototype = {
	__class__: physics_Body
};
var entities_Entity = function(kind) {
	this.states = new coroutines_Coroutines();
	this.maxSpeed = 0.1;
	this.bounds = new geom_Rectangle(0,0,16,16);
	this.acceleration = new geom_Point2D(0,0);
	this.velocity = new geom_Point2D(0,0);
	this.position = new geom_Point2D(0,0);
	this.kind = "entity";
	this.active = true;
	this.kind = kind;
};
entities_Entity.__name__ = true;
entities_Entity.__interfaces__ = [physics_Body];
entities_Entity.prototype = {
	__class__: entities_Entity
};
var entities_Hero = function() {
	entities_Entity.call(this,"hero");
	this.maxSpeed = 0.0666666666666666657;
	this.states.add($bind(this,this.updateNormal));
};
entities_Hero.__name__ = true;
entities_Hero.__super__ = entities_Entity;
entities_Hero.prototype = $extend(entities_Entity.prototype,{
	updateNormal: function() {
		var gamepad = Controller.getInstance().gamepad;
		this.velocity.set(gamepad.axes[0],gamepad.axes[1]).multiply(this.maxSpeed);
		return coroutines_Result.Continue;
	}
	,__class__: entities_Hero
});
var entities_MonsterState = $hxEnums["entities.MonsterState"] = { __ename__ : true, __constructs__ : ["Idle","Seek"]
	,Idle: {_hx_index:0,__enum__:"entities.MonsterState",toString:$estr}
	,Seek: {_hx_index:1,__enum__:"entities.MonsterState",toString:$estr}
};
var entities_Monster = function() {
	this.state = entities_MonsterState.Idle;
	entities_Entity.call(this,"monster");
	this.active = false;
	this.maxSpeed = 0.0666666666666666657;
	this.wanderRate = 0.25;
	this.seekRate = 0.25;
	this.hungerRate = 0.25;
	this.states.add($bind(this,this.updateIdle));
};
entities_Monster.__name__ = true;
entities_Monster.__super__ = entities_Entity;
entities_Monster.prototype = $extend(entities_Entity.prototype,{
	updateIdle: function() {
		var world = Controller.getInstance().model.world;
		this.state = entities_MonsterState.Idle;
		this.changeDirection();
		if(!world.canMove(this,this.target)) {
			return coroutines_Result.Continue;
		} else {
			return coroutines_Result.Push($bind(this,this.updateSeek));
		}
	}
	,updateSeek: function() {
		this.state = entities_MonsterState.Seek;
		var difference = this.target.clone().subtract(this.position);
		var norm = difference.norm();
		if(this.maxSpeed >= norm) {
			this.velocity = difference;
			return coroutines_Result.Terminate;
		} else {
			return coroutines_Result.Continue;
		}
	}
	,targetReached: function() {
		return this.target.floatEqual(this.position);
	}
	,changeDirection: function() {
		var model = Controller.getInstance().model;
		var world = model.world;
		var oldTarget = this.target != null ? this.target.clone() : null;
		var grid = oldTarget != null ? world.toGridCoordinates(oldTarget.x,oldTarget.y) : world.toGridCoordinates(this.position.x,this.position.y);
		if(oldTarget != null) {
			var direction = this.velocity.clone().normalize();
			var newGrid = grid.clone().add(new geom_Point2DInt((direction.x | 0) * 2,(direction.y | 0) * 2));
			this.target = world.toWorldCoordinates(newGrid.x,newGrid.y);
		}
		var hasSeeked = false;
		if(Math.random() < this.seekRate) {
			hasSeeked = true;
			var gridDisplacement = new geom_Point2DInt(0,0);
			var difference = model.hero.position.clone().subtract(this.position);
			if(Math.abs(difference.x) <= Math.abs(difference.y)) {
				gridDisplacement.x = 0;
				gridDisplacement.y = 2;
				if(difference.y < 0) {
					gridDisplacement.y = -2;
				}
			} else {
				gridDisplacement.x = 2;
				gridDisplacement.y = 0;
				if(difference.x < 0) {
					gridDisplacement.x = -2;
				}
			}
			var newGrid1 = grid.clone().add(gridDisplacement);
			this.target = world.toWorldCoordinates(newGrid1.x,newGrid1.y);
		}
		if(this.target == null || !world.canMove(this,this.target) || !hasSeeked && Math.random() < this.wanderRate) {
			while(true) {
				var newGrid2 = grid.clone();
				switch(Math.random() * 4 | 0) {
				case 0:
					newGrid2.add(new geom_Point2DInt(2,0));
					break;
				case 1:
					newGrid2.add(new geom_Point2DInt(0,2));
					break;
				case 2:
					newGrid2.add(new geom_Point2DInt(-2,0));
					break;
				case 3:
					newGrid2.add(new geom_Point2DInt(0,-2));
					break;
				}
				this.target = world.toWorldCoordinates(newGrid2.x,newGrid2.y);
				if(!(!world.canMove(this,this.target))) {
					break;
				}
			}
		}
		var oldDirection = oldTarget != null ? oldTarget.clone().subtract(this.position).normalize() : null;
		var newDirection = this.target.clone().subtract(this.position).normalize();
		if(oldDirection == null || !oldDirection.floatEqual(newDirection)) {
			this.velocity = newDirection.multiply(this.maxSpeed);
		}
	}
	,__class__: entities_Monster
});
var entities_World = function() {
	this.tileIds = [1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1];
	this.tileSize = new geom_Point2DInt(8,8);
	this.gridSize = new geom_Point2DInt(28,18);
	this.transform = new geom_Transform();
	this.active = true;
};
entities_World.__name__ = true;
entities_World.prototype = {
	canMove: function(body,position) {
		var xStart = position.x + body.bounds.x;
		var xEnd = xStart + body.bounds.width;
		var xEndInclusive = !math_MathExtensions.floatEqual(Math,0,math_MathExtensions.modulo(Math,xEnd,this.tileSize.x));
		var yStart = position.y + body.bounds.y;
		var yEnd = yStart + body.bounds.height;
		var yEndInclusive = !math_MathExtensions.floatEqual(Math,0,math_MathExtensions.modulo(Math,yEnd,this.tileSize.y));
		var x = xStart;
		while(xEndInclusive ? x <= xEnd : x < xEnd) {
			var y = yStart;
			while(yEndInclusive ? y <= yEnd : y < yEnd) {
				if(this.getTileIdAt(x,y) > 0) {
					return false;
				}
				y += this.tileSize.y;
			}
			x += this.tileSize.x;
		}
		return true;
	}
	,canMovePoint: function(position) {
		return this.getTileIdAt(position.x,position.y) <= 0;
	}
	,getTileIdAt: function(x,y) {
		var gridCoordinates = this.toGridCoordinates(x,y);
		return this.tileIds[gridCoordinates.x + (this.gridSize.x | 0) * gridCoordinates.y];
	}
	,toGridCoordinates: function(x,y) {
		return new geom_Point2DInt(x / this.tileSize.x | 0,y / this.tileSize.y | 0);
	}
	,toWorldCoordinates: function(x,y) {
		return new geom_Point2D(x * this.tileSize.x,y * this.tileSize.y);
	}
	,__class__: entities_World
};
var events_Emitter = function() {
	this.listeners = new haxe_ds_StringMap();
};
events_Emitter.__name__ = true;
events_Emitter.prototype = {
	on: function(type,listener) {
		var _this = this.listeners;
		if(!(__map_reserved[type] != null ? _this.existsReserved(type) : _this.h.hasOwnProperty(type))) {
			var v = [];
			var _this1 = this.listeners;
			if(__map_reserved[type] != null) {
				_this1.setReserved(type,v);
			} else {
				_this1.h[type] = v;
			}
		}
		var _this2 = this.listeners;
		(__map_reserved[type] != null ? _this2.getReserved(type) : _this2.h[type]).push(listener);
	}
	,off: function(type,listener) {
		var _this = this.listeners;
		if(__map_reserved[type] != null ? _this.existsReserved(type) : _this.h.hasOwnProperty(type)) {
			var _this1 = this.listeners;
			var index = (__map_reserved[type] != null ? _this1.getReserved(type) : _this1.h[type]).lastIndexOf(listener);
			if(index >= 0) {
				var _this2 = this.listeners;
				return (__map_reserved[type] != null ? _this2.getReserved(type) : _this2.h[type]).splice(index,1);
			} else {
				return [];
			}
		} else {
			return [];
		}
	}
	,emit: function(type,event) {
		var _this = this.listeners;
		if(__map_reserved[type] != null ? _this.existsReserved(type) : _this.h.hasOwnProperty(type)) {
			var _g = 0;
			var _this1 = this.listeners;
			var _g1 = __map_reserved[type] != null ? _this1.getReserved(type) : _this1.h[type];
			while(_g < _g1.length) {
				var listener = _g1[_g];
				++_g;
				listener(event);
			}
		}
	}
	,__class__: events_Emitter
};
var events_Event = function(type) {
	this.type = type;
};
events_Event.__name__ = true;
events_Event.prototype = {
	__class__: events_Event
};
var events__$EventType_EventType_$Impl_$ = {};
events__$EventType_EventType_$Impl_$.__name__ = true;
events__$EventType_EventType_$Impl_$._new = function(type) {
	var this1 = type;
	return this1;
};
var events_Events = function() {
	this.queue = [];
	events_Emitter.call(this);
};
events_Events.__name__ = true;
events_Events.__super__ = events_Emitter;
events_Events.prototype = $extend(events_Emitter.prototype,{
	push: function(event) {
		this.queue.push(event);
	}
	,processQueue: function() {
		var _g = 0;
		var _g1 = this.queue.splice(0,this.queue.length);
		while(_g < _g1.length) {
			var event = _g1[_g];
			++_g;
			var key = event.type;
			var _this = this.listeners;
			if(__map_reserved[key] != null ? _this.existsReserved(key) : _this.h.hasOwnProperty(key)) {
				this.emit(event.type,event);
			}
		}
	}
	,__class__: events_Events
});
var gamepad_Gamepad = function() { };
gamepad_Gamepad.__name__ = true;
gamepad_Gamepad.__isInterface__ = true;
gamepad_Gamepad.prototype = {
	__class__: gamepad_Gamepad
};
var gamepad_events_AxisEvent = function(type,x,y,indexes) {
	events_Event.call(this,type);
	this.x = x;
	this.y = y;
	this.indexes = indexes;
};
gamepad_events_AxisEvent.__name__ = true;
gamepad_events_AxisEvent.__super__ = events_Event;
gamepad_events_AxisEvent.prototype = $extend(events_Event.prototype,{
	__class__: gamepad_events_AxisEvent
});
var gamepad_events_AxisPressedEvent = function(x,y,indexes) {
	gamepad_events_AxisEvent.call(this,"axispressed",x,y,indexes);
};
gamepad_events_AxisPressedEvent.__name__ = true;
gamepad_events_AxisPressedEvent.__super__ = gamepad_events_AxisEvent;
gamepad_events_AxisPressedEvent.prototype = $extend(gamepad_events_AxisEvent.prototype,{
	__class__: gamepad_events_AxisPressedEvent
});
var gamepad_events_AxisReleasedEvent = function(indexes) {
	gamepad_events_AxisEvent.call(this,"axisreleased",0,0,indexes);
};
gamepad_events_AxisReleasedEvent.__name__ = true;
gamepad_events_AxisReleasedEvent.__super__ = gamepad_events_AxisEvent;
gamepad_events_AxisReleasedEvent.prototype = $extend(gamepad_events_AxisEvent.prototype,{
	__class__: gamepad_events_AxisReleasedEvent
});
var gamepad_events_ButtonEvent = function(type,pressed,value,index) {
	events_Event.call(this,type);
	this.pressed = pressed;
	this.value = value;
	this.index = index;
};
gamepad_events_ButtonEvent.__name__ = true;
gamepad_events_ButtonEvent.__super__ = events_Event;
gamepad_events_ButtonEvent.prototype = $extend(events_Event.prototype,{
	__class__: gamepad_events_ButtonEvent
});
var gamepad_events_ButtonPressedEvent = function(value,index) {
	gamepad_events_ButtonEvent.call(this,"buttonpressed",true,value,index);
};
gamepad_events_ButtonPressedEvent.__name__ = true;
gamepad_events_ButtonPressedEvent.__super__ = gamepad_events_ButtonEvent;
gamepad_events_ButtonPressedEvent.prototype = $extend(gamepad_events_ButtonEvent.prototype,{
	__class__: gamepad_events_ButtonPressedEvent
});
var gamepad_events_ButtonReleasedEvent = function(index) {
	gamepad_events_ButtonEvent.call(this,"buttonreleased",false,0,index);
};
gamepad_events_ButtonReleasedEvent.__name__ = true;
gamepad_events_ButtonReleasedEvent.__super__ = gamepad_events_ButtonEvent;
gamepad_events_ButtonReleasedEvent.prototype = $extend(gamepad_events_ButtonEvent.prototype,{
	__class__: gamepad_events_ButtonReleasedEvent
});
var gamepad_events_GamepadEvent = function() { };
gamepad_events_GamepadEvent.__name__ = true;
var gamepad_keyboard_KeyboardGamepad = function() {
	this.pureAxes = [0.0,0.0];
	var _g = new haxe_ds_StringMap();
	var value = { type : "axis", index : 1, value : -1.0};
	if(__map_reserved["ArrowUp"] != null) {
		_g.setReserved("ArrowUp",value);
	} else {
		_g.h["ArrowUp"] = value;
	}
	var value1 = { type : "axis", index : 0, value : 1.0};
	if(__map_reserved["ArrowRight"] != null) {
		_g.setReserved("ArrowRight",value1);
	} else {
		_g.h["ArrowRight"] = value1;
	}
	var value2 = { type : "axis", index : 1, value : 1.0};
	if(__map_reserved["ArrowDown"] != null) {
		_g.setReserved("ArrowDown",value2);
	} else {
		_g.h["ArrowDown"] = value2;
	}
	var value3 = { type : "axis", index : 0, value : -1.0};
	if(__map_reserved["ArrowLeft"] != null) {
		_g.setReserved("ArrowLeft",value3);
	} else {
		_g.h["ArrowLeft"] = value3;
	}
	var value4 = { type : "button", index : 0, value : 1.0};
	if(__map_reserved["a"] != null) {
		_g.setReserved("a",value4);
	} else {
		_g.h["a"] = value4;
	}
	this.mappings = _g;
	this.keysStack = [];
	this.buttons = [{ value : 0.0, pressed : false}];
	this.axes = [0.0,0.0];
	var _gthis = this;
	events_Emitter.call(this);
	window.addEventListener("keydown",function(event) {
		_gthis.onKeyDown(event);
		return;
	});
	window.addEventListener("keyup",function(event1) {
		_gthis.onKeyUp(event1);
		return;
	});
};
gamepad_keyboard_KeyboardGamepad.__name__ = true;
gamepad_keyboard_KeyboardGamepad.__interfaces__ = [gamepad_Gamepad];
gamepad_keyboard_KeyboardGamepad.__super__ = events_Emitter;
gamepad_keyboard_KeyboardGamepad.prototype = $extend(events_Emitter.prototype,{
	onKeyDown: function(event) {
		var key = event.key;
		var _this = this.mappings;
		if(__map_reserved[key] != null ? _this.existsReserved(key) : _this.h.hasOwnProperty(key)) {
			var key1 = event.key;
			var _this1 = this.mappings;
			var keymap = __map_reserved[key1] != null ? _this1.getReserved(key1) : _this1.h[key1];
			switch(keymap.type) {
			case "axis":
				if(this.pureAxes[keymap.index] != keymap.value) {
					this.keysStack.push(event.key);
					this.pureAxes[keymap.index] = keymap.value;
					var normalized = new geom_Point2D(this.pureAxes[0],this.pureAxes[1]).normalize();
					this.axes[0] = normalized.x;
					this.axes[1] = normalized.y;
					this.emit("axispressed",new gamepad_events_AxisPressedEvent(this.axes[0],this.axes[1],[0,1]));
				}
				break;
			case "button":
				if(this.buttons[keymap.index].value != keymap.value) {
					this.keysStack.push(event.key);
					this.buttons[keymap.index].value = keymap.value;
					this.buttons[keymap.index].pressed = true;
					this.emit("buttonpressed",new gamepad_events_ButtonPressedEvent(keymap.value,keymap.index));
				}
				break;
			}
		}
	}
	,onKeyUp: function(event) {
		var key = event.key;
		var _this = this.mappings;
		if(__map_reserved[key] != null ? _this.existsReserved(key) : _this.h.hasOwnProperty(key)) {
			var key1 = event.key;
			var _this1 = this.mappings;
			var keymap = __map_reserved[key1] != null ? _this1.getReserved(key1) : _this1.h[key1];
			switch(keymap.type) {
			case "axis":
				var _g = [];
				var _g1 = 0;
				var _g2 = this.keysStack;
				while(_g1 < _g2.length) {
					var v = _g2[_g1];
					++_g1;
					if(v != event.key) {
						_g.push(v);
					}
				}
				this.keysStack = _g;
				if(this.reverseKeyInStack(event.key)) {
					this.pureAxes[keymap.index] = -this.pureAxes[keymap.index];
				} else {
					this.pureAxes[keymap.index] = 0.0;
				}
				var normalized = new geom_Point2D(this.pureAxes[0],this.pureAxes[1]).normalize();
				this.axes[0] = normalized.x;
				this.axes[1] = normalized.y;
				if(this.axes[0] == 0.0 && this.axes[1] == 0.0) {
					this.emit("axisreleased",new gamepad_events_AxisReleasedEvent([0,1]));
				} else {
					this.emit("axispressed",new gamepad_events_AxisPressedEvent(this.axes[0],this.axes[1],[0,1]));
				}
				break;
			case "button":
				var _g3 = [];
				var _g11 = 0;
				var _g21 = this.keysStack;
				while(_g11 < _g21.length) {
					var v1 = _g21[_g11];
					++_g11;
					if(v1 != event.key) {
						_g3.push(v1);
					}
				}
				this.keysStack = _g3;
				this.buttons[keymap.index].value = 0.0;
				this.buttons[keymap.index].pressed = false;
				this.emit("buttonreleased",new gamepad_events_ButtonReleasedEvent(keymap.index));
				break;
			}
		}
	}
	,reverseKeyInStack: function(key) {
		var _g = new haxe_iterators_MapKeyValueIterator(this.mappings);
		while(_g.hasNext()) {
			var _g1 = _g.next();
			var reverseKey = _g1.key;
			var map = _g1.value;
			var tmp;
			var _this = this.mappings;
			if(map.index == (__map_reserved[key] != null ? _this.getReserved(key) : _this.h[key]).index) {
				var _this1 = this.mappings;
				tmp = map.value == -(__map_reserved[key] != null ? _this1.getReserved(key) : _this1.h[key]).value;
			} else {
				tmp = false;
			}
			if(tmp && this.keysStack.indexOf(reverseKey) >= 0) {
				return true;
			}
		}
		return false;
	}
	,__class__: gamepad_keyboard_KeyboardGamepad
});
var gamepad_multi_MultiGamepad = function() {
	this.buttons = [{ value : 0.0, pressed : false}];
	this.axes = [0.0,0.0];
	var _gthis = this;
	events_Emitter.call(this);
	this.touchGamepad = new gamepad_touch_TouchGamepad({ axisDistance : 64, eightDirectional : true, dualHands : false});
	this.keyboardGamepad = new gamepad_keyboard_KeyboardGamepad();
	this.touchGamepad.on("axispressed",function(event) {
		_gthis.onAxisPressed(event);
		return;
	});
	this.touchGamepad.on("axisreleased",function(event1) {
		_gthis.onAxisReleased(event1);
		return;
	});
	this.touchGamepad.on("buttonpressed",function(event2) {
		_gthis.onButtonPressed(event2);
		return;
	});
	this.touchGamepad.on("buttonreleased",function(event3) {
		_gthis.onButtonReleased(event3);
		return;
	});
	this.keyboardGamepad.on("axispressed",function(event4) {
		_gthis.onAxisPressed(event4);
		return;
	});
	this.keyboardGamepad.on("axisreleased",function(event5) {
		_gthis.onAxisReleased(event5);
		return;
	});
	this.keyboardGamepad.on("buttonpressed",function(event6) {
		_gthis.onButtonPressed(event6);
		return;
	});
	this.keyboardGamepad.on("buttonreleased",function(event7) {
		_gthis.onButtonReleased(event7);
		return;
	});
};
gamepad_multi_MultiGamepad.__name__ = true;
gamepad_multi_MultiGamepad.__interfaces__ = [gamepad_Gamepad];
gamepad_multi_MultiGamepad.__super__ = events_Emitter;
gamepad_multi_MultiGamepad.prototype = $extend(events_Emitter.prototype,{
	onAxisPressed: function(event) {
		this.axes[event.indexes[0]] = event.x;
		this.axes[event.indexes[1]] = event.y;
		this.emit("axispressed",event);
	}
	,onAxisReleased: function(event) {
		this.axes[event.indexes[0]] = event.x;
		this.axes[event.indexes[1]] = event.y;
		this.emit("axisreleased",event);
	}
	,onButtonPressed: function(event) {
		this.buttons[event.index].pressed = event.pressed;
		this.buttons[event.index].value = event.value;
		this.emit("buttonpressed",event);
	}
	,onButtonReleased: function(event) {
		this.buttons[event.index].pressed = event.pressed;
		this.buttons[event.index].value = event.value;
		this.emit("buttonreleased",event);
	}
	,__class__: gamepad_multi_MultiGamepad
});
var gamepad_touch_TouchGamepad = function(options) {
	this.regions = [];
	this.buttons = [{ value : 0.0, pressed : false}];
	this.axes = [0.0,0.0];
	var _gthis = this;
	events_Emitter.call(this);
	this.options = options;
	this.surface = new gamepad_touch_TouchSurface({ delayTouchStart : !this.options.dualHands, touchStartDistanceThresold : !this.options.dualHands ? 7 : 0, tapTimeThresold : !this.options.dualHands ? 100 : 0});
	if(this.options.dualHands) {
		this.regions.push(new gamepad_touch_TouchRegion({ surface : this.surface, region : new geom_Rectangle(0,0,0.5,1)}));
		this.regions.push(new gamepad_touch_TouchRegion({ surface : this.surface, region : new geom_Rectangle(0.5,0,0.5,1)}));
	} else {
		this.regions.push(new gamepad_touch_TouchRegion({ surface : this.surface, region : new geom_Rectangle(0,0,1,1)}));
	}
	var _g = 0;
	var _g1 = this.regions.length;
	while(_g < _g1) {
		var i = [_g++];
		this.regions[i[0]].on("touchstart",(function(i1) {
			return function(event) {
				_gthis.onTouchStart(i1[0],event);
				return;
			};
		})(i));
		this.regions[i[0]].on("touchmove",(function(i2) {
			return function(event1) {
				_gthis.onTouchMove(i2[0],event1);
				return;
			};
		})(i));
		this.regions[i[0]].on("touchend",(function(i3) {
			return function(event2) {
				_gthis.onTouchEnd(i3[0],event2);
				return;
			};
		})(i));
		this.regions[i[0]].on("touchendoutside",(function(i4) {
			return function(event3) {
				_gthis.onTouchEndOutside(i4[0],event3);
				return;
			};
		})(i));
		this.regions[i[0]].on("tappressed",(function(i5) {
			return function(event4) {
				_gthis.onTapPressed(i5[0],event4);
				return;
			};
		})(i));
		this.regions[i[0]].on("tapreleased",(function(i6) {
			return function(event5) {
				_gthis.onTapReleased(i6[0],event5);
				return;
			};
		})(i));
	}
};
gamepad_touch_TouchGamepad.__name__ = true;
gamepad_touch_TouchGamepad.__interfaces__ = [gamepad_Gamepad];
gamepad_touch_TouchGamepad.__super__ = events_Emitter;
gamepad_touch_TouchGamepad.prototype = $extend(events_Emitter.prototype,{
	onTouchStart: function(regionIndex,event) {
		if(regionIndex == 1 && this.options.dualHands) {
			var index = 0;
			this.buttons[index].value = 1;
			this.buttons[index].pressed = true;
			this.emit("buttonpressed",new gamepad_events_ButtonPressedEvent(this.buttons[index].value,index));
		}
	}
	,onTouchMove: function(regionIndex,event) {
		var displacement = new geom_Point2D(event.touch.moveX,event.touch.moveY);
		if(displacement.equal(new geom_Point2D(0,0))) {
			this.axes[0] = 0;
			this.axes[1] = 0;
		} else {
			var norm = displacement.norm();
			var normalizedValue = Math.min(this.options.axisDistance,norm) / this.options.axisDistance;
			if(this.options.eightDirectional) {
				var angle = 2 * Math.PI * this.discretizedAngle(8,displacement) / 8;
				displacement = new geom_Point2D(Math.cos(angle),Math.sin(angle)).multiply(normalizedValue);
			} else {
				displacement.multiply(normalizedValue / norm);
			}
			this.axes[0] = displacement.x;
			this.axes[1] = displacement.y;
		}
		if(!this.options.dualHands && this.buttons[0].pressed) {
			var index = 0;
			this.buttons[index].value = 0;
			this.buttons[index].pressed = false;
			this.emit("buttonreleased",new gamepad_events_ButtonReleasedEvent(index));
		}
		this.emit("axispressed",new gamepad_events_AxisPressedEvent(this.axes[0],this.axes[1],[0,1]));
	}
	,onTouchEnd: function(regionIndex,event) {
		if(regionIndex == 1 && this.options.dualHands) {
			var index = 0;
			this.buttons[index].value = 0;
			this.buttons[index].pressed = false;
			this.emit("buttonreleased",new gamepad_events_ButtonReleasedEvent(index));
		} else if(regionIndex == 0) {
			this.axes[0] = 0;
			this.axes[1] = 0;
			this.emit("axisreleased",new gamepad_events_AxisReleasedEvent([0,1]));
		}
	}
	,onTouchEndOutside: function(regionIndex,event) {
		this.axes[0] = 0;
		this.axes[1] = 0;
		this.emit("axisreleased",new gamepad_events_AxisReleasedEvent([0,1]));
	}
	,onTapPressed: function(regionIndex,event) {
		if(regionIndex == 0 && !this.options.dualHands) {
			var index = 0;
			this.buttons[index].value = 1;
			this.buttons[index].pressed = true;
			this.emit("buttonpressed",new gamepad_events_ButtonPressedEvent(this.buttons[index].value,index));
		}
	}
	,onTapReleased: function(regionIndex,event) {
		if(regionIndex == 0 && !this.options.dualHands) {
			var index = 0;
			this.buttons[index].value = 0;
			this.buttons[index].pressed = false;
			this.emit("buttonreleased",new gamepad_events_ButtonReleasedEvent(index));
		}
	}
	,discretizedAngle: function(n,v) {
		var a = Math.atan2(v.y,v.x) / 2 / Math.PI * n + 0.5;
		return Math.floor(a + (a < 0 ? n : 0));
	}
	,__class__: gamepad_touch_TouchGamepad
});
var gamepad_touch_TouchRegion = function(options) {
	this.touches = [];
	events_Emitter.call(this);
	this.options = options;
	this.options.surface.on("tappressed",$bind(this,this.onTapPressed));
	this.options.surface.on("tapreleased",$bind(this,this.onTapReleased));
	this.options.surface.on("touchstart",$bind(this,this.onTouchStart));
	this.options.surface.on("touchmove",$bind(this,this.onTouchMove));
	this.options.surface.on("touchend",$bind(this,this.onTouchEnd));
	this.options.surface.on("touchendoutside",$bind(this,this.onTouchEndOutside));
};
gamepad_touch_TouchRegion.__name__ = true;
gamepad_touch_TouchRegion.__super__ = events_Emitter;
gamepad_touch_TouchRegion.prototype = $extend(events_Emitter.prototype,{
	onTapPressed: function(event) {
		if(this.inRegion({ x : event.touch.x, y : event.touch.y},this.options.region)) {
			if(this.findTouch(event.touch)._hx_index == 1) {
				this.touches.push(event.touch);
			}
			this.emit("tappressed",event);
		}
	}
	,onTapReleased: function(event) {
		if(this.inRegion({ x : event.touch.x, y : event.touch.y},this.options.region)) {
			var _g = this.findTouch(event.touch);
			if(_g._hx_index == 0) {
				var touch = _g.v;
				HxOverrides.remove(this.touches,touch);
				this.emit("tapreleased",event);
			}
		}
	}
	,onTouchStart: function(event) {
		if(this.inRegion({ x : event.touch.x, y : event.touch.y},this.options.region)) {
			if(this.findTouch(event.touch)._hx_index == 1) {
				this.touches.push(event.touch);
			}
			this.emit("touchstart",event);
		}
	}
	,onTouchMove: function(event) {
		if(this.inRegion({ x : event.touch.x, y : event.touch.y},this.options.region)) {
			var _g = this.findTouch(event.touch);
			if(_g._hx_index == 0) {
				var touch = _g.v;
				touch.x = event.touch.x;
				touch.y = event.touch.y;
				this.emit("touchmove",event);
			}
		}
	}
	,onTouchEnd: function(event) {
		if(this.inRegion({ x : event.touch.x, y : event.touch.y},this.options.region)) {
			var _g = this.findTouch(event.touch);
			if(_g._hx_index == 0) {
				var touch = _g.v;
				HxOverrides.remove(this.touches,touch);
				this.emit("touchend",event);
			}
		} else {
			var _g1 = this.findTouch(event.touch);
			if(_g1._hx_index == 0) {
				var touch1 = _g1.v;
				HxOverrides.remove(this.touches,touch1);
				this.emit("touchendoutside",new gamepad_touch_events_TouchEndOutsideEvent(event.touch,event.touches));
			}
		}
	}
	,onTouchEndOutside: function(event) {
		if(this.inRegion({ x : event.touch.x, y : event.touch.y},this.options.region)) {
			var _g = this.findTouch(event.touch);
			if(_g._hx_index == 0) {
				var touch = _g.v;
				HxOverrides.remove(this.touches,touch);
				this.emit("touchendoutside",event);
			}
		}
	}
	,findTouch: function(touch1) {
		var _g = 0;
		var _g1 = this.touches;
		while(_g < _g1.length) {
			var touch2 = _g1[_g];
			++_g;
			if(touch1.id == touch2.id) {
				return haxe_ds_Option.Some(touch2);
			}
		}
		return haxe_ds_Option.None;
	}
	,inRegion: function(point,region) {
		if(region.x * window.innerWidth <= point.x && point.x <= (region.x + region.width) * window.innerWidth && region.y * window.innerHeight <= point.y) {
			return point.y <= (region.y + region.height) * window.innerHeight;
		} else {
			return false;
		}
	}
	,__class__: gamepad_touch_TouchRegion
});
var gamepad_touch_TouchState = function(id,x,y) {
	this.id = id;
	this.x = x;
	this.y = y;
	this.startX = x;
	this.startY = y;
	this.moveX = 0;
	this.moveY = 0;
	this.pressed = false;
	this.started = false;
	this.startTime = new Date().getTime();
};
gamepad_touch_TouchState.__name__ = true;
gamepad_touch_TouchState.prototype = {
	__class__: gamepad_touch_TouchState
};
var gamepad_touch_TouchSurface = function(options) {
	this.touches = [];
	events_Emitter.call(this);
	this.options = options;
	this.distanceThresholdSquared = this.options.touchStartDistanceThresold * this.options.touchStartDistanceThresold;
	window.document.body.style.touchAction = "none";
	window.document.addEventListener("pointerdown",$bind(this,this.onPointerDown));
	window.document.addEventListener("pointermove",$bind(this,this.onPointerMove));
	window.document.addEventListener("pointerup",$bind(this,this.onPointerUp));
};
gamepad_touch_TouchSurface.__name__ = true;
gamepad_touch_TouchSurface.__super__ = events_Emitter;
gamepad_touch_TouchSurface.prototype = $extend(events_Emitter.prototype,{
	onPointerDown: function(event) {
		var _gthis = this;
		var touch = new gamepad_touch_TouchState(this.nextId(),event.x,event.y);
		this.touches.push(touch);
		if(this.options.delayTouchStart) {
			var timer = new haxe_Timer(this.options.tapTimeThresold);
			timer.run = function() {
				timer.stop();
				if(!touch.started && !touch.pressed) {
					touch.pressed = true;
					_gthis.emit("tappressed",new gamepad_touch_events_TapPressedEvent(touch,_gthis.touches));
				}
			};
		} else {
			touch.started = true;
			this.emit("touchstart",new gamepad_touch_events_TouchStartEvent(touch,this.touches));
		}
	}
	,onPointerMove: function(event) {
		var touch = this.findClosest({ x : event.x, y : event.y},this.touches);
		if(touch != null) {
			touch.moveX = event.x - touch.startX;
			touch.moveY = event.y - touch.startY;
			touch.x = event.x;
			touch.y = event.y;
			if(!touch.started && this.distanceSquared({ x : touch.x, y : touch.y},{ x : touch.startX, y : touch.startY}) >= this.distanceThresholdSquared) {
				touch.started = true;
				this.emit("touchstart",new gamepad_touch_events_TouchStartEvent(touch,this.touches));
			} else if(touch.started) {
				this.emit("touchmove",new gamepad_touch_events_TouchMoveEvent(touch,this.touches));
			}
		}
	}
	,onPointerUp: function(event) {
		var touch = this.findClosest({ x : event.x, y : event.y},this.touches);
		if(touch != null) {
			this.touches.splice(this.touches.indexOf(touch),1);
			touch.moveX = event.x - touch.startX;
			touch.moveY = event.y - touch.startY;
			touch.x = event.x;
			touch.y = event.y;
			if(touch.started) {
				this.emit("touchend",new gamepad_touch_events_TouchEndEvent(touch,this.touches));
			} else {
				if(!touch.pressed) {
					touch.pressed = true;
					this.emit("tappressed",new gamepad_touch_events_TapPressedEvent(touch,this.touches));
				}
				this.emit("tapreleased",new gamepad_touch_events_TapReleasedEvent(touch,this.touches));
			}
		}
	}
	,nextId: function() {
		this.touches.sort(function(a,b) {
			return b.id - a.id;
		});
		var id = 0;
		var i = 0;
		while(i < this.touches.length && id >= this.touches[i].id) {
			id = this.touches[i].id + 1;
			++i;
		}
		return id;
	}
	,findClosest: function(touch,touches) {
		var closest = null;
		var minDist = Infinity;
		var _g = 0;
		while(_g < touches.length) {
			var touch2 = touches[_g];
			++_g;
			var dx = touch.x - touch2.x;
			var dy = touch.y - touch2.y;
			var dist = dx * dx + dy * dy;
			if(closest == null || dist < minDist) {
				closest = touch2;
				minDist = dist;
			}
		}
		return closest;
	}
	,distanceSquared: function(u,v) {
		var x = u.x - v.x;
		var y = u.y - v.y;
		return x * x + y * y;
	}
	,__class__: gamepad_touch_TouchSurface
});
var gamepad_touch_events_TouchEvent = function(type,touch,touches) {
	this.type = type;
	this.touch = touch;
	this.touches = touches;
};
gamepad_touch_events_TouchEvent.__name__ = true;
gamepad_touch_events_TouchEvent.prototype = {
	__class__: gamepad_touch_events_TouchEvent
};
var gamepad_touch_events_TapPressedEvent = function(touch,touches) {
	gamepad_touch_events_TouchEvent.call(this,"tappressed",touch,touches);
};
gamepad_touch_events_TapPressedEvent.__name__ = true;
gamepad_touch_events_TapPressedEvent.__super__ = gamepad_touch_events_TouchEvent;
gamepad_touch_events_TapPressedEvent.prototype = $extend(gamepad_touch_events_TouchEvent.prototype,{
	__class__: gamepad_touch_events_TapPressedEvent
});
var gamepad_touch_events_TapReleasedEvent = function(touch,touches) {
	gamepad_touch_events_TouchEvent.call(this,"tapreleased",touch,touches);
};
gamepad_touch_events_TapReleasedEvent.__name__ = true;
gamepad_touch_events_TapReleasedEvent.__super__ = gamepad_touch_events_TouchEvent;
gamepad_touch_events_TapReleasedEvent.prototype = $extend(gamepad_touch_events_TouchEvent.prototype,{
	__class__: gamepad_touch_events_TapReleasedEvent
});
var gamepad_touch_events_TouchEndEvent = function(touch,touches) {
	gamepad_touch_events_TouchEvent.call(this,"touchend",touch,touches);
};
gamepad_touch_events_TouchEndEvent.__name__ = true;
gamepad_touch_events_TouchEndEvent.__super__ = gamepad_touch_events_TouchEvent;
gamepad_touch_events_TouchEndEvent.prototype = $extend(gamepad_touch_events_TouchEvent.prototype,{
	__class__: gamepad_touch_events_TouchEndEvent
});
var gamepad_touch_events_TouchEndOutsideEvent = function(touch,touches) {
	gamepad_touch_events_TouchEvent.call(this,"touchendoutside",touch,touches);
};
gamepad_touch_events_TouchEndOutsideEvent.__name__ = true;
gamepad_touch_events_TouchEndOutsideEvent.__super__ = gamepad_touch_events_TouchEvent;
gamepad_touch_events_TouchEndOutsideEvent.prototype = $extend(gamepad_touch_events_TouchEvent.prototype,{
	__class__: gamepad_touch_events_TouchEndOutsideEvent
});
var gamepad_touch_events_TouchMoveEvent = function(touch,touches) {
	gamepad_touch_events_TouchEvent.call(this,"touchmove",touch,touches);
};
gamepad_touch_events_TouchMoveEvent.__name__ = true;
gamepad_touch_events_TouchMoveEvent.__super__ = gamepad_touch_events_TouchEvent;
gamepad_touch_events_TouchMoveEvent.prototype = $extend(gamepad_touch_events_TouchEvent.prototype,{
	__class__: gamepad_touch_events_TouchMoveEvent
});
var gamepad_touch_events_TouchStartEvent = function(touch,touches) {
	gamepad_touch_events_TouchEvent.call(this,"touchstart",touch,touches);
};
gamepad_touch_events_TouchStartEvent.__name__ = true;
gamepad_touch_events_TouchStartEvent.__super__ = gamepad_touch_events_TouchEvent;
gamepad_touch_events_TouchStartEvent.prototype = $extend(gamepad_touch_events_TouchEvent.prototype,{
	__class__: gamepad_touch_events_TouchStartEvent
});
var geom_Point2D = function(x,y) {
	this.set(x,y);
};
geom_Point2D.__name__ = true;
geom_Point2D.prototype = {
	set: function(x,y) {
		this.x = x;
		this.y = y;
		return this;
	}
	,setFromPoint2D: function(p) {
		this.x = p.x;
		this.y = p.y;
		return this;
	}
	,setX: function(x) {
		this.x = x;
		return this;
	}
	,setY: function(y) {
		this.y = y;
		return this;
	}
	,equal: function(v) {
		if(this.x == v.x) {
			return this.y == v.y;
		} else {
			return false;
		}
	}
	,floatEqual: function(v,epsilon) {
		if(epsilon == null) {
			epsilon = 0.0001;
		}
		if(math_MathExtensions.floatEqual(Math,this.x,v.x,epsilon)) {
			return math_MathExtensions.floatEqual(Math,this.y,v.y,epsilon);
		} else {
			return false;
		}
	}
	,clone: function() {
		return new geom_Point2D(this.x,this.y);
	}
	,copyTo: function(v) {
		v.x = this.x;
		v.y = this.y;
		return v;
	}
	,copyFrom: function(v) {
		this.x = v.x;
		this.y = v.y;
		return this;
	}
	,add: function(v) {
		this.x += v.x;
		this.y += v.y;
		return this;
	}
	,subtract: function(v) {
		this.x -= v.x;
		this.y -= v.y;
		return this;
	}
	,multiply: function(a) {
		this.x *= a;
		this.y *= a;
		return this;
	}
	,dot: function(v) {
		return this.x * v.x + this.y * v.y;
	}
	,norm: function() {
		return Math.sqrt(this.dot(this));
	}
	,normalize: function() {
		var norm = this.norm();
		if(norm != 0) {
			return this.multiply(1 / norm);
		} else {
			return this;
		}
	}
	,__class__: geom_Point2D
};
var geom_Point2DInt = function(x,y) {
	this.set(x,y);
};
geom_Point2DInt.__name__ = true;
geom_Point2DInt.prototype = {
	set: function(x,y) {
		this.x = x;
		this.y = y;
		return this;
	}
	,setX: function(x) {
		this.x = x;
		return this;
	}
	,setY: function(y) {
		this.y = y;
		return this;
	}
	,equal: function(v) {
		if(this.x == v.x) {
			return this.y == v.y;
		} else {
			return false;
		}
	}
	,clone: function() {
		return new geom_Point2DInt(this.x,this.y);
	}
	,copyTo: function(v) {
		v.x = this.x;
		v.y = this.y;
		return v;
	}
	,copyFrom: function(v) {
		this.x = v.x;
		this.y = v.y;
		return this;
	}
	,add: function(v) {
		this.x += v.x;
		this.y += v.y;
		return this;
	}
	,subtract: function(v) {
		this.x -= v.x;
		this.y -= v.y;
		return this;
	}
	,multiply: function(a) {
		this.x *= a;
		this.y *= a;
		return this;
	}
	,dot: function(v) {
		return this.x * v.x + this.y * v.y;
	}
	,norm: function() {
		return Math.sqrt(this.dot(this));
	}
	,normalize: function() {
		var point = new geom_Point2D(this.x,this.y);
		var norm = this.norm();
		if(norm != 0) {
			return point.multiply(1 / norm);
		} else {
			return point;
		}
	}
	,__class__: geom_Point2DInt
};
var geom_Rectangle = function(x,y,width,height) {
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
};
geom_Rectangle.__name__ = true;
geom_Rectangle.prototype = {
	clone: function() {
		return new geom_Rectangle(this.x,this.y,this.width,this.height);
	}
	,copyTo: function(r) {
		r.x = this.x;
		r.y = this.y;
		r.width = this.width;
		r.height = this.height;
		return r;
	}
	,equal: function(r) {
		if(this.x == r.x && this.y == r.y && this.width == r.width) {
			return this.height == r.height;
		} else {
			return false;
		}
	}
	,translate: function(v) {
		this.x += v.x;
		this.y += v.y;
		return this;
	}
	,overlap: function(r) {
		if(this.x < r.x + r.width && r.x < this.x + this.width && this.y < r.y + r.height) {
			return r.y < this.y + this.height;
		} else {
			return false;
		}
	}
	,__class__: geom_Rectangle
};
var geom_RectangleOperations = function() { };
geom_RectangleOperations.__name__ = true;
geom_RectangleOperations.equal = function(r1,r2) {
	return r1.clone().equal(r2);
};
geom_RectangleOperations.translate = function(r,v) {
	return r.clone().translate(v);
};
geom_RectangleOperations.overlap = function(r1,r2) {
	return r1.clone().overlap(r2);
};
var geom_Transform = function() {
	this.translate = new geom_Point2D(0,0);
};
geom_Transform.__name__ = true;
geom_Transform.prototype = {
	__class__: geom_Transform
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
haxe_IMap.__isInterface__ = true;
haxe_IMap.prototype = {
	__class__: haxe_IMap
};
var haxe_Timer = function(time_ms) {
	var me = this;
	this.id = setInterval(function() {
		me.run();
	},time_ms);
};
haxe_Timer.__name__ = true;
haxe_Timer.prototype = {
	stop: function() {
		if(this.id == null) {
			return;
		}
		clearInterval(this.id);
		this.id = null;
	}
	,run: function() {
	}
	,__class__: haxe_Timer
};
var haxe_ds_Option = $hxEnums["haxe.ds.Option"] = { __ename__ : true, __constructs__ : ["Some","None"]
	,Some: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.ds.Option",toString:$estr}; },$_.__params__ = ["v"],$_)
	,None: {_hx_index:1,__enum__:"haxe.ds.Option",toString:$estr}
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	get: function(key) {
		if(__map_reserved[key] != null) {
			return this.getReserved(key);
		}
		return this.h[key];
	}
	,setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	,existsReserved: function(key) {
		if(this.rh == null) {
			return false;
		}
		return this.rh.hasOwnProperty("$" + key);
	}
	,keys: function() {
		return HxOverrides.iter(this.arrayKeys());
	}
	,arrayKeys: function() {
		var out = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) {
			out.push(key);
		}
		}
		if(this.rh != null) {
			for( var key in this.rh ) {
			if(key.charCodeAt(0) == 36) {
				out.push(key.substr(1));
			}
			}
		}
		return out;
	}
	,__class__: haxe_ds_StringMap
};
var haxe_iterators_MapKeyValueIterator = function(map) {
	this.map = map;
	this.keys = map.keys();
};
haxe_iterators_MapKeyValueIterator.__name__ = true;
haxe_iterators_MapKeyValueIterator.prototype = {
	hasNext: function() {
		return this.keys.hasNext();
	}
	,next: function() {
		var key = this.keys.next();
		return { value : this.map.get(key), key : key};
	}
	,__class__: haxe_iterators_MapKeyValueIterator
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if(((val) instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
	__class__: js__$Boot_HaxeError
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g3 = 0;
			var _g11 = o.length;
			while(_g3 < _g11) {
				var i = _g3++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e1 ) {
			var e2 = ((e1) instanceof js__$Boot_HaxeError) ? e1.val : e1;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str1 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str1.length != 2) {
			str1 += ", \n";
		}
		str1 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str1 += "\n" + s + "}";
		return str1;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	if(Object.prototype.hasOwnProperty.call(cc,"__interfaces__")) {
		var intf = cc.__interfaces__;
		var _g = 0;
		var _g1 = intf.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		return ((o) instanceof Array);
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return o != null;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(js_Boot.__downcastCheck(o,cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(((o) instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
	}
};
js_Boot.__downcastCheck = function(o,cl) {
	if(!((o) instanceof cl)) {
		if(cl.__isInterface__) {
			return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
		} else {
			return false;
		}
	} else {
		return true;
	}
};
js_Boot.__cast = function(o,t) {
	if(o == null || js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw new js__$Boot_HaxeError("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var loader_Loader = function() {
	this.queue = [];
	this.cache = new haxe_ds_StringMap();
	events_Emitter.call(this);
};
loader_Loader.__name__ = true;
loader_Loader.__super__ = events_Emitter;
loader_Loader.prototype = $extend(events_Emitter.prototype,{
	add: function(id,url,type) {
		var _this = this.cache;
		var found = __map_reserved[id] != null ? _this.existsReserved(id) : _this.h.hasOwnProperty(id);
		if(!found) {
			var _g = 0;
			var _g1 = this.queue;
			while(_g < _g1.length) {
				var resource = _g1[_g];
				++_g;
				if(resource.id == id) {
					found = true;
					break;
				}
			}
		}
		if(!found) {
			if(type == null) {
				type = HxOverrides.substr(url,url.lastIndexOf(".") + 1,null);
			}
			this.queue.push({ id : id, type : type, url : url});
		}
		return this;
	}
	,load: function() {
		var _gthis = this;
		this.emit("loadstart");
		var totalCount = this.queue.length;
		var count = 0;
		var helper = null;
		helper = function(queue) {
			if(queue.length == 0) {
				_gthis.emit("loadcomplete");
				return Promise.resolve([]);
			} else {
				var query = queue[0];
				return window.fetch(query.url).then(function(response) {
					return _gthis.parseResponse(query,response);
				}).then(function(data) {
					var resource = { id : query.id, type : query.type, url : query.url, data : data};
					var k = resource.id;
					var _this = _gthis.cache;
					if(__map_reserved[k] != null) {
						_this.setReserved(k,resource);
					} else {
						_this.h[k] = resource;
					}
					var helper1 = count += 1;
					_gthis.emit("loadprogress",helper1 / totalCount);
					var helper2 = queue.slice(1);
					return helper(helper2).then(function(rest) {
						return [resource].concat(rest);
					});
				},function(error) {
					throw js__$Boot_HaxeError.wrap(error);
				});
			}
		};
		var tmp = this.queue.splice(0,this.queue.length);
		return helper(tmp);
	}
	,parseResponse: function(query,response) {
		switch(query.type) {
		case "bmp":case "image":case "jpeg":case "jpg":case "png":case "webp":
			return this.parseImage(query,response);
		case "json":
			return this.parseJson(query,response);
		case "svg":
			return this.parseSvg(query,response);
		case "text":
			return this.parseText(query,response);
		default:
			return this.parseText(query,response);
		}
	}
	,parseSvg: function(query,response) {
		return response.text().then(function(svg) {
			var tpl = window.document.createElement("template");
			tpl.innerHTML = svg;
			return js_Boot.__cast(tpl.content.children[0] , SVGSVGElement);
		});
	}
	,parseImage: function(query,response) {
		var img = window.document.createElement("img");
		img.src = query.url;
		return img;
	}
	,parseText: function(query,response) {
		return response.text();
	}
	,parseJson: function(query,response) {
		return response.json();
	}
	,__class__: loader_Loader
});
var loader_events_LoaderEvent = function() { };
loader_events_LoaderEvent.__name__ = true;
var math_MathExtensions = function() { };
math_MathExtensions.__name__ = true;
math_MathExtensions.floatEqual = function(cl,x,y,epsilon) {
	if(epsilon == null) {
		epsilon = 0.0001;
	}
	return Math.abs(x - y) < epsilon;
};
math_MathExtensions.modulo = function(cl,x,y) {
	if(x < 0) {
		return x % y + y;
	} else {
		return x % y;
	}
};
var physics_Physics = function(model) {
	this.model = model;
};
physics_Physics.__name__ = true;
physics_Physics.prototype = {
	fixedUpdate: function(deltaTime) {
		var _g = 0;
		var _g1 = this.model.getBodies();
		while(_g < _g1.length) {
			var body = _g1[_g];
			++_g;
			body.velocity.add(body.acceleration);
			this.model.move(body,body.position.clone().add(body.velocity));
		}
	}
	,__class__: physics_Physics
};
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
Date.prototype.__class__ = Date;
Date.__name__ = "Date";
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
var __map_reserved = {};
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
js_Boot.__toStr = ({ }).toString;
View.SVG_NS = "http://www.w3.org/2000/svg";
gamepad_events_GamepadEvent.AxisPressed = "axispressed";
gamepad_events_GamepadEvent.AxisReleased = "axisreleased";
gamepad_events_GamepadEvent.ButtonPressed = "buttonpressed";
gamepad_events_GamepadEvent.ButtonReleased = "buttonreleased";
gamepad_touch_events_TouchEvent.TouchStart = "touchstart";
gamepad_touch_events_TouchEvent.TouchMove = "touchmove";
gamepad_touch_events_TouchEvent.TouchEnd = "touchend";
gamepad_touch_events_TouchEvent.TouchEndOutside = "touchendoutside";
gamepad_touch_events_TouchEvent.TapPressed = "tappressed";
gamepad_touch_events_TouchEvent.TapReleased = "tapreleased";
loader_events_LoaderEvent.LoadStart = "loadstart";
loader_events_LoaderEvent.LoadProgress = "loadprogress";
loader_events_LoaderEvent.LoadComplete = "loadcomplete";
Main.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
