// Generated by Haxe 4.0.5
(function ($global) { "use strict";
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var Controller = function(model,view) {
	this.fixedTimeLeft = 0;
	this.fixedTimeStep = 2.08333333333333348;
	this.paused = false;
	this.started = false;
	this.model = model;
	this.view = view;
	this.events = new events_Events();
	this.physics = new physics_Physics();
	this.viewport = new geom_Rectangle(0,0,0,0);
	this.gamepad = new gamepad_MultiGamepad();
};
Controller.prototype = {
	start: function() {
		var _gthis = this;
		if(!this.started) {
			this.started = true;
			this.model.init();
			this.initEvents();
			var loop = null;
			loop = function(currentTime) {
				if(!_gthis.paused) {
					var viewport = new geom_Rectangle(0,0,window.innerWidth,window.innerHeight);
					if(_gthis.lastTime == null) {
						viewport.copyTo(_gthis.viewport);
						_gthis.view.resize(viewport);
						_gthis.events.processQueue();
						_gthis.view.visible = true;
						_gthis.view.update();
						_gthis.lastTime = currentTime;
						_gthis.fixedTimeLeft = 0;
					} else {
						if(!geom_Rectangle.equal(_gthis.viewport,viewport)) {
							viewport.copyTo(_gthis.viewport);
							_gthis.view.resize(viewport);
						}
						_gthis.events.processQueue();
						var deltaTime = currentTime - _gthis.lastTime;
						_gthis.fixedTimeLeft += deltaTime;
						while(_gthis.fixedTimeLeft >= _gthis.fixedTimeStep) {
							_gthis.physics.update(_gthis.fixedTimeStep);
							_gthis.fixedTimeLeft -= _gthis.fixedTimeStep;
						}
						_gthis.view.update();
						_gthis.lastTime = currentTime;
					}
					window.requestAnimationFrame(loop);
				}
			};
			window.requestAnimationFrame(loop);
		}
	}
	,initEvents: function() {
		var _gthis = this;
		this.gamepad.on("axispressed",function(event) {
			_gthis.events.push(event);
			return;
		});
		this.gamepad.on("axisreleased",function(event1) {
			_gthis.events.push(event1);
			return;
		});
		this.gamepad.on("buttonpressed",function(event2) {
			_gthis.events.push(event2);
			return;
		});
		this.gamepad.on("buttonreleased",function(event3) {
			_gthis.events.push(event3);
			return;
		});
	}
};
var HxOverrides = function() { };
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var Main = function() { };
Main.main = function() {
	var model = new Model();
	var controller = new Controller(model,new View(model));
	controller.start();
	window.controller = controller;
};
var Model = function() {
	this.world = new entities_World();
	this.hero = new entities_Hero();
	var _g = [];
	_g.push(new entities_Enemy());
	_g.push(new entities_Enemy());
	_g.push(new entities_Enemy());
	_g.push(new entities_Enemy());
	_g.push(new entities_Enemy());
	_g.push(new entities_Enemy());
	_g.push(new entities_Enemy());
	_g.push(new entities_Enemy());
	_g.push(new entities_Enemy());
	_g.push(new entities_Enemy());
	this.enemies = _g;
};
Model.prototype = {
	init: function() {
		var tileSize = this.world.tileSize;
		var gridSize = this.world.gridSize;
		var tmp = ((Math.random() * 4 | 0) + 5) * tileSize.x;
		this.hero.position.x = tmp * 2;
		var tmp1 = ((Math.random() * 3 | 0) + 3) * tileSize.y;
		this.hero.position.y = tmp1 * 2;
		while(!this.world.canMove(this.hero,this.hero.position)) {
			var tmp2 = ((Math.random() * 4 | 0) + 5) * tileSize.x;
			this.hero.position.x = tmp2 * 2;
			var tmp3 = ((Math.random() * 3 | 0) + 3) * tileSize.y;
			this.hero.position.y = tmp3 * 2;
		}
		var heroRegion = new geom_Rectangle(this.hero.position.x + this.hero.bounds.x - this.world.tileSize.x,this.hero.position.y + this.hero.bounds.y - this.world.tileSize.y,this.hero.bounds.width + 2 * this.world.tileSize.x,this.hero.bounds.height + 2 * this.world.tileSize.y);
		var _g = 0;
		var _g1 = this.enemies.slice(0,4);
		while(_g < _g1.length) {
			var enemy = _g1[_g];
			++_g;
			enemy.active = true;
			var x = Math.random();
			enemy.position.x = ((x * (gridSize.x / 2 - 2) | 0) + 1) * tileSize.x * 2;
			var x1 = Math.random();
			enemy.position.y = ((x1 * (gridSize.y / 2 - 2) | 0) + 1) * tileSize.y * 2;
			while(!this.world.canMove(enemy,enemy.position) || geom_Rectangle.overlap(heroRegion,enemy.bounds)) {
				var x2 = Math.random();
				enemy.position.x = ((x2 * (gridSize.x / 2 - 2) | 0) + 1) * tileSize.x * 2;
				var x3 = Math.random();
				enemy.position.y = ((x3 * (gridSize.y / 2 - 2) | 0) + 1) * tileSize.y * 2;
			}
		}
	}
};
var View = function(model) {
	this.enemies = [];
	this.tiles = [];
	this.visible = false;
	this.model = model;
	this.root = this.createRoot();
	this.scene = this.createScene();
	this.root.appendChild(this.scene);
	this.world = this.createWorld();
	this.scene.appendChild(this.world);
	var _g = 0;
	var _g1 = model.world.tileIds.length;
	while(_g < _g1) {
		var index = _g++;
		var tileId = model.world.tileIds[index];
		var x = index % model.world.gridSize.x * model.world.tileSize.x;
		var y = (index / model.world.gridSize.x | 0) * model.world.tileSize.y;
		var tile = this.createTile(tileId,x,y,model.world.tileSize.x,model.world.tileSize.y);
		this.world.appendChild(tile);
		this.tiles.push(tile);
	}
	var _g2 = 0;
	var _g3 = model.enemies;
	while(_g2 < _g3.length) {
		var enemyModel = _g3[_g2];
		++_g2;
		var enemy = this.createEnemy(enemyModel);
		this.scene.appendChild(enemy);
		this.enemies.push(enemy);
	}
	this.hero = this.createHero(model.hero);
	this.scene.appendChild(this.hero);
	window.document.body.appendChild(this.root);
};
View.prototype = {
	update: function() {
		this.root.style.visibility = this.visible ? "" : "hidden";
		this.hero.style.visibility = this.model.hero.active ? "" : "hidden";
		if(this.model.hero.active) {
			this.hero.setAttributeNS(null,"cx",this.model.hero.position.x + this.model.hero.bounds.width / 2 + "px");
			this.hero.setAttributeNS(null,"cy",this.model.hero.position.y + this.model.hero.bounds.height / 2 + "px");
			this.hero.setAttributeNS(null,"rx",this.model.hero.bounds.width / 2 + "px");
			this.hero.setAttributeNS(null,"yy",this.model.hero.bounds.height / 2 + "px");
		}
		var _g = 0;
		var _g1 = this.model.enemies.length;
		while(_g < _g1) {
			var index = _g++;
			var enemyModel = this.model.enemies[index];
			var enemyView = this.enemies[index];
			enemyView.style.visibility = enemyModel.active ? "" : "hidden";
			if(enemyModel.active) {
				enemyView.setAttributeNS(null,"cx",enemyModel.position.x + enemyModel.bounds.width / 2 + "px");
				enemyView.setAttributeNS(null,"cy",enemyModel.position.y + enemyModel.bounds.height / 2 + "px");
				enemyView.setAttributeNS(null,"rx",enemyModel.bounds.width / 2 + "px");
				enemyView.setAttributeNS(null,"yy",enemyModel.bounds.height / 2 + "px");
			}
		}
	}
	,resize: function(viewport) {
		var width = this.model.world.gridSize.x * this.model.world.tileSize.x;
		var height = this.model.world.gridSize.y * this.model.world.tileSize.y;
		var scale = Math.min(viewport.width / width,viewport.height / height);
		this.scene.setAttributeNS(null,"transform","scale(" + scale + ") translate(" + (viewport.width / scale - width) / 2 + " " + (viewport.height / scale - height) / 2 + ")");
		this.root.setAttributeNS(null,"width",viewport.width + "");
		this.root.setAttributeNS(null,"height",viewport.height + "");
	}
	,createRoot: function() {
		var _g = new haxe_ds_StringMap();
		var value = window.innerWidth;
		if(__map_reserved["width"] != null) {
			_g.setReserved("width",value);
		} else {
			_g.h["width"] = value;
		}
		var value1 = window.innerHeight;
		if(__map_reserved["height"] != null) {
			_g.setReserved("height",value1);
		} else {
			_g.h["height"] = value1;
		}
		var _g1 = new haxe_ds_StringMap();
		var value2 = "hidden";
		if(__map_reserved["visibility"] != null) {
			_g1.setReserved("visibility",value2);
		} else {
			_g1.h["visibility"] = value2;
		}
		return this.createElement("svg",_g,_g1);
	}
	,createScene: function() {
		var _g = new haxe_ds_StringMap();
		var value = "scene";
		if(__map_reserved["class"] != null) {
			_g.setReserved("class",value);
		} else {
			_g.h["class"] = value;
		}
		return this.createElement("g",_g);
	}
	,createWorld: function() {
		var _g = new haxe_ds_StringMap();
		var value = "world";
		if(__map_reserved["class"] != null) {
			_g.setReserved("class",value);
		} else {
			_g.h["class"] = value;
		}
		return this.createElement("g",_g);
	}
	,createTile: function(tileId,x,y,width,height) {
		var _g = new haxe_ds_StringMap();
		var value = ["ground","block"][tileId];
		if(__map_reserved["class"] != null) {
			_g.setReserved("class",value);
		} else {
			_g.h["class"] = value;
		}
		var value1 = "" + x + "px";
		if(__map_reserved["x"] != null) {
			_g.setReserved("x",value1);
		} else {
			_g.h["x"] = value1;
		}
		var value2 = "" + y + "px";
		if(__map_reserved["y"] != null) {
			_g.setReserved("y",value2);
		} else {
			_g.h["y"] = value2;
		}
		var value3 = "" + width + "px";
		if(__map_reserved["width"] != null) {
			_g.setReserved("width",value3);
		} else {
			_g.h["width"] = value3;
		}
		var value4 = "" + height + "px";
		if(__map_reserved["height"] != null) {
			_g.setReserved("height",value4);
		} else {
			_g.h["height"] = value4;
		}
		var value5 = ["#303030","#808080"][tileId];
		if(__map_reserved["fill"] != null) {
			_g.setReserved("fill",value5);
		} else {
			_g.h["fill"] = value5;
		}
		var value6 = "crispEdges";
		if(__map_reserved["shape-rendering"] != null) {
			_g.setReserved("shape-rendering",value6);
		} else {
			_g.h["shape-rendering"] = value6;
		}
		return this.createElement("rect",_g);
	}
	,createHero: function(hero) {
		var _g = new haxe_ds_StringMap();
		var value = "hero";
		if(__map_reserved["class"] != null) {
			_g.setReserved("class",value);
		} else {
			_g.h["class"] = value;
		}
		var value1 = "" + hero.bounds.width / 2 + "px";
		if(__map_reserved["cx"] != null) {
			_g.setReserved("cx",value1);
		} else {
			_g.h["cx"] = value1;
		}
		var value2 = "" + hero.bounds.height / 2 + "px";
		if(__map_reserved["cy"] != null) {
			_g.setReserved("cy",value2);
		} else {
			_g.h["cy"] = value2;
		}
		var value3 = "" + hero.bounds.width / 2 + "px";
		if(__map_reserved["rx"] != null) {
			_g.setReserved("rx",value3);
		} else {
			_g.h["rx"] = value3;
		}
		var value4 = "" + hero.bounds.height / 2 + "px";
		if(__map_reserved["ry"] != null) {
			_g.setReserved("ry",value4);
		} else {
			_g.h["ry"] = value4;
		}
		var value5 = "#3366cc";
		if(__map_reserved["fill"] != null) {
			_g.setReserved("fill",value5);
		} else {
			_g.h["fill"] = value5;
		}
		return this.createElement("ellipse",_g);
	}
	,createEnemy: function(enemy) {
		var _g = new haxe_ds_StringMap();
		var value = "enemy";
		if(__map_reserved["class"] != null) {
			_g.setReserved("class",value);
		} else {
			_g.h["class"] = value;
		}
		var value1 = "" + enemy.bounds.width / 2 + "px";
		if(__map_reserved["cx"] != null) {
			_g.setReserved("cx",value1);
		} else {
			_g.h["cx"] = value1;
		}
		var value2 = "" + enemy.bounds.height / 2 + "px";
		if(__map_reserved["cy"] != null) {
			_g.setReserved("cy",value2);
		} else {
			_g.h["cy"] = value2;
		}
		var value3 = "" + enemy.bounds.width / 2 + "px";
		if(__map_reserved["rx"] != null) {
			_g.setReserved("rx",value3);
		} else {
			_g.h["rx"] = value3;
		}
		var value4 = "" + enemy.bounds.height / 2 + "px";
		if(__map_reserved["ry"] != null) {
			_g.setReserved("ry",value4);
		} else {
			_g.h["ry"] = value4;
		}
		var value5 = "#cc0066";
		if(__map_reserved["fill"] != null) {
			_g.setReserved("fill",value5);
		} else {
			_g.h["fill"] = value5;
		}
		return this.createElement("ellipse",_g);
	}
	,createElement: function(name,attributes,style) {
		var element = window.document.createElementNS("http://www.w3.org/2000/svg",name);
		if(attributes != null) {
			var _g = new haxe_iterators_MapKeyValueIterator(attributes);
			while(_g.hasNext()) {
				var _g1 = _g.next();
				var key = _g1.key;
				var value = _g1.value;
				element.setAttributeNS(null,key,value);
			}
		}
		if(style != null) {
			var _g2 = new haxe_iterators_MapKeyValueIterator(style);
			while(_g2.hasNext()) {
				var _g11 = _g2.next();
				var key1 = _g11.key;
				var value1 = _g11.value;
				element.style[key1] = value1;
			}
		}
		return element;
	}
};
var entities_Enemy = function() {
	this.walkSpeed = 0.0666666666666666657;
	this.bounds = new geom_Rectangle(0,0,16,16);
	this.acceleration = new geom_Point2D(0,0);
	this.velocity = new geom_Point2D(0,0);
	this.position = new geom_Point2D(0,0);
	this.name = "enemy";
	this.active = false;
};
var entities_Hero = function() {
	this.walkSpeed = 0.0666666666666666657;
	this.bounds = new geom_Rectangle(0,0,16,16);
	this.acceleration = new geom_Point2D(0,0);
	this.velocity = new geom_Point2D(0,0);
	this.position = new geom_Point2D(0,0);
	this.name = "hero";
	this.active = true;
};
var entities_World = function() {
	this.tileIds = [1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1];
	this.tileSize = new geom_Point2D(8,8);
	this.gridSize = new geom_Point2D(28,18);
	this.transform = new geom_Transform();
	this.name = "world";
	this.active = true;
};
entities_World.prototype = {
	canMove: function(entity,position) {
		var xStart = position.x + entity.bounds.x;
		var xEnd = xStart + entity.bounds.width;
		var xEndInclusive = !math_MathExtensions.floatEqual(Math,0,math_MathExtensions.modulo(Math,xEnd,this.tileSize.x));
		var yStart = position.y + entity.bounds.y;
		var yEnd = yStart + entity.bounds.height;
		var yEndInclusive = !math_MathExtensions.floatEqual(Math,0,math_MathExtensions.modulo(Math,yEnd,this.tileSize.y));
		var x = xStart;
		while(xEndInclusive ? x <= xEnd : x < xEnd) {
			var y = yStart;
			while(yEndInclusive ? y <= yEnd : y < yEnd) {
				if(this.getTileIdAt(x,y) > 0) {
					return false;
				}
				y += this.tileSize.y;
			}
			x += this.tileSize.x;
		}
		return true;
	}
	,getTileIdAt: function(x,y) {
		var xIndex = x / this.tileSize.x | 0;
		var yIndex = y / this.tileSize.y | 0;
		return this.tileIds[xIndex + (this.gridSize.x | 0) * yIndex];
	}
};
var events_Emitter = function() {
	this.listeners = new haxe_ds_StringMap();
};
events_Emitter.prototype = {
	on: function(type,listener) {
		var _this = this.listeners;
		if(!(__map_reserved[type] != null ? _this.existsReserved(type) : _this.h.hasOwnProperty(type))) {
			var v = [];
			var _this1 = this.listeners;
			if(__map_reserved[type] != null) {
				_this1.setReserved(type,v);
			} else {
				_this1.h[type] = v;
			}
		}
		var _this2 = this.listeners;
		(__map_reserved[type] != null ? _this2.getReserved(type) : _this2.h[type]).push(listener);
	}
	,off: function(type,listener) {
		var _this = this.listeners;
		if(__map_reserved[type] != null ? _this.existsReserved(type) : _this.h.hasOwnProperty(type)) {
			var _this1 = this.listeners;
			var index = (__map_reserved[type] != null ? _this1.getReserved(type) : _this1.h[type]).lastIndexOf(listener);
			if(index >= 0) {
				var _this2 = this.listeners;
				return (__map_reserved[type] != null ? _this2.getReserved(type) : _this2.h[type]).splice(index,1);
			} else {
				return [];
			}
		} else {
			return [];
		}
	}
	,emit: function(type,event) {
		var _this = this.listeners;
		if(__map_reserved[type] != null ? _this.existsReserved(type) : _this.h.hasOwnProperty(type)) {
			var _g = 0;
			var _this1 = this.listeners;
			var _g1 = __map_reserved[type] != null ? _this1.getReserved(type) : _this1.h[type];
			while(_g < _g1.length) {
				var listener = _g1[_g];
				++_g;
				listener(event);
			}
		}
	}
};
var events_Event = function(type) {
	this.type = type;
};
var events__$EventType_EventType_$Impl_$ = {};
events__$EventType_EventType_$Impl_$._new = function(type) {
	var this1 = type;
	return this1;
};
var events_Events = function() {
	this.queue = [];
	events_Emitter.call(this);
};
events_Events.__super__ = events_Emitter;
events_Events.prototype = $extend(events_Emitter.prototype,{
	push: function(event) {
		this.queue.push(event);
	}
	,processQueue: function() {
		var _g = 0;
		var _g1 = this.queue.splice(0,this.queue.length);
		while(_g < _g1.length) {
			var event = _g1[_g];
			++_g;
			var key = event.type;
			var _this = this.listeners;
			if(__map_reserved[key] != null ? _this.existsReserved(key) : _this.h.hasOwnProperty(key)) {
				this.emit(event.type,event);
			}
		}
	}
});
var gamepad_AxisEvent = function(type,x,y,indexes) {
	events_Event.call(this,type);
	this.x = x;
	this.y = y;
	this.indexes = indexes;
};
gamepad_AxisEvent.__super__ = events_Event;
gamepad_AxisEvent.prototype = $extend(events_Event.prototype,{
});
var gamepad_AxisPressedEvent = function(x,y,indexes) {
	gamepad_AxisEvent.call(this,"axispressed",x,y,indexes);
};
gamepad_AxisPressedEvent.__super__ = gamepad_AxisEvent;
gamepad_AxisPressedEvent.prototype = $extend(gamepad_AxisEvent.prototype,{
});
var gamepad_AxisReleasedEvent = function(indexes) {
	gamepad_AxisEvent.call(this,"axisreleased",0,0,indexes);
};
gamepad_AxisReleasedEvent.__super__ = gamepad_AxisEvent;
gamepad_AxisReleasedEvent.prototype = $extend(gamepad_AxisEvent.prototype,{
});
var gamepad_ButtonEvent = function(type,pressed,value,index) {
	events_Event.call(this,type);
	this.pressed = pressed;
	this.value = value;
	this.index = index;
};
gamepad_ButtonEvent.__super__ = events_Event;
gamepad_ButtonEvent.prototype = $extend(events_Event.prototype,{
});
var gamepad_ButtonPressedEvent = function(value,index) {
	gamepad_ButtonEvent.call(this,"buttonpressed",true,value,index);
};
gamepad_ButtonPressedEvent.__super__ = gamepad_ButtonEvent;
gamepad_ButtonPressedEvent.prototype = $extend(gamepad_ButtonEvent.prototype,{
});
var gamepad_ButtonReleasedEvent = function(index) {
	gamepad_ButtonEvent.call(this,"buttonreleased",false,0,index);
};
gamepad_ButtonReleasedEvent.__super__ = gamepad_ButtonEvent;
gamepad_ButtonReleasedEvent.prototype = $extend(gamepad_ButtonEvent.prototype,{
});
var gamepad_GamepadEvent = function() { };
var gamepad_KeyboardGamepad = function() {
	this.buttons = [{ value : 0.0, pressed : false}];
	this.axes = [0.0,0.0];
	var _g = new haxe_ds_StringMap();
	var value = { type : "axis", index : 0, value : 1.0};
	if(__map_reserved["ArrowUp"] != null) {
		_g.setReserved("ArrowUp",value);
	} else {
		_g.h["ArrowUp"] = value;
	}
	var value1 = { type : "axis", index : 0, value : 1.0};
	if(__map_reserved["ArrowRight"] != null) {
		_g.setReserved("ArrowRight",value1);
	} else {
		_g.h["ArrowRight"] = value1;
	}
	var value2 = { type : "axis", index : 0, value : -1.0};
	if(__map_reserved["ArrowDown"] != null) {
		_g.setReserved("ArrowDown",value2);
	} else {
		_g.h["ArrowDown"] = value2;
	}
	var value3 = { type : "axis", index : 0, value : -1.0};
	if(__map_reserved["ArrowLeft"] != null) {
		_g.setReserved("ArrowLeft",value3);
	} else {
		_g.h["ArrowLeft"] = value3;
	}
	var value4 = { type : "button", index : 0, value : 1.0};
	if(__map_reserved["a"] != null) {
		_g.setReserved("a",value4);
	} else {
		_g.h["a"] = value4;
	}
	this.mappings = _g;
	var _gthis = this;
	events_Emitter.call(this);
	window.addEventListener("keydown",function(event) {
		_gthis.onKeyDown(event);
		return;
	});
	window.addEventListener("keyup",function(event1) {
		_gthis.onKeyUp(event1);
		return;
	});
};
gamepad_KeyboardGamepad.__super__ = events_Emitter;
gamepad_KeyboardGamepad.prototype = $extend(events_Emitter.prototype,{
	onKeyDown: function(event) {
		var key = event.key;
		var _this = this.mappings;
		if(__map_reserved[key] != null ? _this.existsReserved(key) : _this.h.hasOwnProperty(key)) {
			var key1 = event.key;
			var _this1 = this.mappings;
			var keymap = __map_reserved[key1] != null ? _this1.getReserved(key1) : _this1.h[key1];
			switch(keymap.type) {
			case "axis":
				if(this.axes[keymap.index] != keymap.value) {
					this.axes[keymap.index] = keymap.value;
					this.emit("axispressed",new gamepad_AxisPressedEvent(this.axes[0],this.axes[1],[0,1]));
				}
				break;
			case "button":
				if(this.buttons[keymap.index].value != keymap.value) {
					this.buttons[keymap.index].value = keymap.value;
					this.buttons[keymap.index].pressed = true;
					this.emit("buttonpressed",new gamepad_ButtonPressedEvent(keymap.value,keymap.index));
				}
				break;
			}
		}
	}
	,onKeyUp: function(event) {
		var key = event.key;
		var _this = this.mappings;
		if(__map_reserved[key] != null ? _this.existsReserved(key) : _this.h.hasOwnProperty(key)) {
			var key1 = event.key;
			var _this1 = this.mappings;
			var keymap = __map_reserved[key1] != null ? _this1.getReserved(key1) : _this1.h[key1];
			switch(keymap.type) {
			case "axis":
				if(this.axes[keymap.index] != 0.0) {
					this.axes[keymap.index] = 0.0;
					this.emit("axisreleased",new gamepad_AxisReleasedEvent([0,1]));
				}
				break;
			case "button":
				if(this.buttons[keymap.index].value != 0.0) {
					this.buttons[keymap.index].value = 0.0;
					this.buttons[keymap.index].pressed = false;
					this.emit("buttonreleased",new gamepad_ButtonReleasedEvent(keymap.index));
				}
				break;
			}
		}
	}
});
var gamepad_MultiGamepad = function() {
	this.buttons = [{ value : 0.0, pressed : false}];
	this.axes = [0.0,0.0];
	var _gthis = this;
	events_Emitter.call(this);
	this.touchGamepad = new touchGamepad.TouchGamepad();
	this.keyboardGamepad = new gamepad_KeyboardGamepad();
	this.touchGamepad.on("axispressed",function(event) {
		_gthis.onAxisPressed(event);
		return;
	});
	this.touchGamepad.on("axisreleased",function(event1) {
		_gthis.onAxisReleased(event1);
		return;
	});
	this.touchGamepad.on("buttonpressed",function(event2) {
		_gthis.onButtonPressed(event2);
		return;
	});
	this.touchGamepad.on("buttonreleased",function(event3) {
		_gthis.onButtonReleased(event3);
		return;
	});
	this.keyboardGamepad.on("axispressed",function(event4) {
		_gthis.onAxisPressed(event4);
		return;
	});
	this.keyboardGamepad.on("axisreleased",function(event5) {
		_gthis.onAxisReleased(event5);
		return;
	});
	this.keyboardGamepad.on("buttonpressed",function(event6) {
		_gthis.onButtonPressed(event6);
		return;
	});
	this.keyboardGamepad.on("buttonreleased",function(event7) {
		_gthis.onButtonReleased(event7);
		return;
	});
};
gamepad_MultiGamepad.__super__ = events_Emitter;
gamepad_MultiGamepad.prototype = $extend(events_Emitter.prototype,{
	onAxisPressed: function(event) {
		this.axes[event.indexes[0]] = event.x;
		this.axes[event.indexes[1]] = event.y;
		this.emit("axispressed",event);
	}
	,onAxisReleased: function(event) {
		this.axes[event.indexes[0]] = event.x;
		this.axes[event.indexes[1]] = event.y;
		this.emit("axisreleased",event);
	}
	,onButtonPressed: function(event) {
		this.buttons[event.index].pressed = event.pressed;
		this.buttons[event.index].value = event.value;
		this.emit("buttonpressed",event);
	}
	,onButtonReleased: function(event) {
		this.buttons[event.index].pressed = event.pressed;
		this.buttons[event.index].value = event.value;
		this.emit("buttonreleased",event);
	}
});
var geom_Point2D = function(x,y) {
	this.x = x;
	this.y = y;
};
geom_Point2D.dot = function(u,v) {
	return u.x * v.x + u.y * v.y;
};
geom_Point2D.add = function(u,v) {
	return new geom_Point2D(u.x + v.x,u.y + v.y);
};
geom_Point2D.subtract = function(u,v) {
	return new geom_Point2D(u.x - v.x,u.y - v.y);
};
geom_Point2D.multiply = function(u,a) {
	return new geom_Point2D(u.x * a,u.y * a);
};
geom_Point2D.norm = function(v) {
	return Math.sqrt(geom_Point2D.dot(v,v));
};
geom_Point2D.normalize = function(v) {
	var norm = geom_Point2D.norm(v);
	if(norm != 0) {
		return geom_Point2D.multiply(v,1 / norm);
	} else {
		return new geom_Point2D(0,0);
	}
};
geom_Point2D.prototype = {
	copyTo: function(v) {
		v.x = this.x;
		v.y = this.y;
		return v;
	}
};
var geom_Rectangle = function(x,y,width,height) {
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
};
geom_Rectangle.equal = function(r1,r2) {
	if(r1.x == r2.x && r1.y == r2.y && r1.width == r2.width) {
		return r1.height == r2.height;
	} else {
		return false;
	}
};
geom_Rectangle.translate = function(rectangle,translation) {
	return new geom_Rectangle(rectangle.x + translation.x,rectangle.y + translation.y,rectangle.width,rectangle.height);
};
geom_Rectangle.overlap = function(r1,r2) {
	if(r1.x < r2.x + r2.width && r2.x < r1.x + r1.width && r1.y < r2.y + r2.height) {
		return r2.y < r1.y + r1.height;
	} else {
		return false;
	}
};
geom_Rectangle.prototype = {
	copyTo: function(rectangle) {
		rectangle.x = this.x;
		rectangle.y = this.y;
		rectangle.width = this.width;
		rectangle.height = this.height;
		return rectangle;
	}
};
var geom_Transform = function() {
	this.translate = new geom_Point2D(0,0);
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.prototype = {
	get: function(key) {
		if(__map_reserved[key] != null) {
			return this.getReserved(key);
		}
		return this.h[key];
	}
	,setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	,existsReserved: function(key) {
		if(this.rh == null) {
			return false;
		}
		return this.rh.hasOwnProperty("$" + key);
	}
	,keys: function() {
		return HxOverrides.iter(this.arrayKeys());
	}
	,arrayKeys: function() {
		var out = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) {
			out.push(key);
		}
		}
		if(this.rh != null) {
			for( var key in this.rh ) {
			if(key.charCodeAt(0) == 36) {
				out.push(key.substr(1));
			}
			}
		}
		return out;
	}
};
var haxe_iterators_MapKeyValueIterator = function(map) {
	this.map = map;
	this.keys = map.keys();
};
haxe_iterators_MapKeyValueIterator.prototype = {
	hasNext: function() {
		return this.keys.hasNext();
	}
	,next: function() {
		var key = this.keys.next();
		return { value : this.map.get(key), key : key};
	}
};
var math_MathExtensions = function() { };
math_MathExtensions.floatEqual = function(cl,x,y,epsilon) {
	if(epsilon == null) {
		epsilon = 0.0001;
	}
	return Math.abs(x - y) < epsilon;
};
math_MathExtensions.modulo = function(cl,x,y) {
	if(x < 0) {
		return x % y + y;
	} else {
		return x % y;
	}
};
var physics_Physics = function() {
};
physics_Physics.prototype = {
	update: function(deltaTime) {
	}
};
var __map_reserved = {};
View.SVG_NS = "http://www.w3.org/2000/svg";
gamepad_GamepadEvent.AxisPressed = "axispressed";
gamepad_GamepadEvent.AxisReleased = "axisreleased";
gamepad_GamepadEvent.ButtonPressed = "buttonpressed";
gamepad_GamepadEvent.ButtonReleased = "buttonreleased";
Main.main();
})({});
